{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Index/","title":"Main","text":""},{"location":"projects/","title":"Projects","text":"<p>Hallo sehr geehrte Damen und Herren, hier finden Sie ein \u00dcberblick \u00fcber alle bisherigen Projekte  bzw. laufenden Projekte.</p>"},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/","title":"\ud83d\udcc3 Algorithmen und Datenstruktur","text":"","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#einfuhrung-in-algorithmen-und-datenstrukturen","title":"Einf\u00fchrung in Algorithmen und Datenstrukturen","text":"<p>Ein Algorithmus ist eine systematische Methode zur L\u00f6sung eines Problems in endlich vielen Schritten. Er kann als Rezept oder Anleitung verstanden werden.</p> <p>Eine Datenstruktur ist eine M\u00f6glichkeit, Daten effizient zu speichern und zu organisieren.</p>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#2-suchalgorithmen","title":"2. Suchalgorithmen","text":"","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#21-lineare-suche","title":"2.1 Lineare Suche","text":"<ul> <li>Die einfachste Methode zur Suche in einer Liste.</li> <li>Durchl\u00e4uft alle Elemente nacheinander.</li> <li>Laufzeit: O(n) im Worst Case.</li> </ul>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#test-der-tabs-funktion","title":"\ud83d\udccb Test der Tabs-Funktion","text":"<p>=== \"\ud83d\udcdd C-Code\"</p> <pre><code>```c\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n```\n</code></pre> <p>=== \"\ud83d\udcca Python-Code\"</p> <pre><code>```python\ndef greet():\n    print(\"Hello, World!\")\n\ngreet()\n```\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nint lineare_suche(int arr[], int n, int ziel) {\n    for (int i = 0; i &lt; n; i++) {\n        if (arr[i] == ziel)\n            return i;  // Index des gefundenen Elements\n    }\n    return -1;  // Nicht gefunden\n}\n\nint main() {\n    int arr[] = {4, 2, 9, 7, 5, 8};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int ziel = 7;\n    int index = lineare_suche(arr, n, ziel);\n\n    if (index != -1)\n        printf(\"Element gefunden an Index %d\\n\", index);\n    else\n        printf(\"Element nicht gefunden\\n\");\n\n    return 0;\n}\n\n</code></pre> <p> </p>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#22-binare-suche-binary-search","title":"2.2 Bin\u00e4re Suche (Binary Search)","text":"<ul> <li>Prinzip: Linker Knoten &lt; Parent; Rechter Knoten &gt; Parent.</li> <li>Funktioniert nur bei sortierten Listen.</li> <li>Durchsucht Liste durch wiederholtes Halbieren.</li> <li>Laufzeit: O(log n) im Worst Case.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint binaere_suche(int arr[], int links, int rechts, int ziel) {\n    while (links &lt;= rechts) {\n        int mitte = links + (rechts - links) / 2;\n\n        if (arr[mitte] == ziel)\n            return mitte;\n        else if (arr[mitte] &lt; ziel)\n            links = mitte + 1;\n        else\n            rechts = mitte - 1;\n    }\n    return -1;  // Nicht gefunden\n}\n\nint main() {\n    int arr[] = {1, 3, 5, 7, 9, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int ziel = 7;\n    int index = binaere_suche(arr, 0, n - 1, ziel);\n\n    if (index != -1)\n        printf(\"Element gefunden an Index %d\\n\", index);\n    else\n        printf(\"Element nicht gefunden\\n\");\n\n    return 0;\n}\n</code></pre>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#3-sortieralgorithmen","title":"3. Sortieralgorithmen","text":"","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#31-bubble-sort","title":"3.1 Bubble Sort","text":"<ul> <li>Vergleicht benachbarte Elemente und vertauscht sie.</li> <li>Sehr ineffizient: O(n\u00b2).</li> </ul>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#schritt-fur-schritt","title":"Schritt-f\u00fcr-Schritt","text":"<ol> <li>Gehe durch die Liste und vergleiche benachbarte Elemente.</li> <li>Tausche sie, falls das linke gr\u00f6\u00dfer als das rechte ist.</li> <li>Wiederhole den Vorgang, bis keine Vertauschung mehr n\u00f6tig ist.</li> </ol> <pre><code>void bubble_sort(int arr[], int n) { //Arraygr\u00f6\u00dfe als Parameter in C\n    for (int i = 0; i &lt; n - 1; i++) {\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                // Elemente tauschen\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n</code></pre>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#32-quicksort","title":"3.2 Quicksort","text":"<ul> <li>Ein Divide &amp; Conquer Algorithmus.</li> <li>W\u00e4hlt ein Pivot-Element aus, partitioniert die Liste und sortiert rekursiv die beiden H\u00e4lften.</li> <li>Laufzeit: O(n log n) im Durchschnitt.</li> </ul>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#schritt-fur-schritt_1","title":"Schritt-f\u00fcr-Schritt","text":"<ol> <li>W\u00e4hle ein Pivot-Element (z. B. das letzte Element).</li> <li>Partitioniere die Liste in:<ul> <li>Elemente kleiner als Pivot.</li> <li>Das Pivot-Element.</li> <li>Elemente gr\u00f6\u00dfer als Pivot.</li> </ul> </li> <li>Rufe Quicksort rekursiv f\u00fcr die beiden Teile auf.</li> </ol> <pre><code>#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];  \n    int i = (low - 1);\n\n    for (int j = low; j &lt; high; j++) {\n        if (arr[j] &lt; pivot) {\n            i++;\n            swap(&amp;arr[i], &amp;arr[j]);\n        }\n    }\n    swap(&amp;arr[i + 1], &amp;arr[high]);\n    return (i + 1);\n}\n\nvoid quicksort(int arr[], int low, int high) {\n    if (low &lt; high) {\n        int pi = partition(arr, low, high);\n        quicksort(arr, low, pi - 1);\n        quicksort(arr, pi + 1, high);\n    }\n}\n\nvoid print_array(int arr[], int n) {\n    for (int i = 0; i &lt; n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {5, 3, 8, 4, 2};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    quicksort(arr, 0, n - 1);\n    printf(\"Sortiertes Array: \");\n    print_array(arr, n);\n\n    return 0;\n}\n</code></pre> <p>In unserem grafischen Beispiel: <code>Pivot = Array[Array size / 2]</code> </p>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#4-baume","title":"4. B\u00e4ume","text":"<p>Ein Baum ist eine rekursive Datenstruktur mit Knoten, die miteinander verbunden sind. Der oberste Knoten hei\u00dft Wurzel.</p>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#41-binare-suchbaume-bst","title":"4.1 Bin\u00e4re Suchb\u00e4ume (BST)","text":"<ul> <li>Jeder Knoten hat h\u00f6chstens zwei Kinder.</li> <li>Linkes Kind kleiner, rechtes Kind gr\u00f6\u00dfer als der Elternknoten.</li> <li>Suchen, Einf\u00fcgen und L\u00f6schen in O(log n).</li> </ul>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#einfugen-in-einen-bst","title":"Einf\u00fcgen in einen BST","text":"<ol> <li>Falls der Baum leer ist \u2192 neues Element wird die Wurzel.</li> <li>Falls der Wert kleiner ist \u2192 gehe nach links.</li> <li>Falls der Wert gr\u00f6\u00dfer ist \u2192 gehe nach rechts.</li> <li>Wiederhole, bis eine freie Position gefunden wurde.</li> </ol> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Knoten {\n    int wert;\n    struct Knoten *links, *rechts;\n};\n\nstruct Knoten* neuerKnoten(int wert) {\n    struct Knoten* knoten = (struct Knoten*)malloc(sizeof(struct Knoten));\n    knoten-&gt;wert = wert;\n    knoten-&gt;links = knoten-&gt;rechts = NULL;\n    return knoten;\n}\n\nstruct Knoten* einfuegen(struct Knoten* wurzel, int wert) {\n    if (wurzel == NULL)\n        return neuerKnoten(wert);\n\n    if (wert &lt; wurzel-&gt;wert)\n        wurzel-&gt;links = einfuegen(wurzel-&gt;links, wert);\n    else\n        wurzel-&gt;rechts = einfuegen(wurzel-&gt;rechts, wert);\n\n    return wurzel;\n}\n\nvoid inorder(struct Knoten* wurzel) {\n    if (wurzel != NULL) {\n        inorder(wurzel-&gt;links);\n        printf(\"%d \", wurzel-&gt;wert);\n        inorder(wurzel-&gt;rechts);\n    }\n}\n\nint main() {\n    struct Knoten* wurzel = NULL;\n    wurzel = einfuegen(wurzel, 5);\n    wurzel = einfuegen(wurzel, 3);\n    wurzel = einfuegen(wurzel, 7);\n    wurzel = einfuegen(wurzel, 2);\n    wurzel = einfuegen(wurzel, 4);\n\n    printf(\"Inorder Traversierung: \");\n    inorder(wurzel);\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#5-heaps-und-prioritatswarteschlangen","title":"5. Heaps und Priorit\u00e4tswarteschlangen","text":"<p>Ein Heap ist eine spezielle Bin\u00e4rbaum-Datenstruktur:</p> <ul> <li>Ein Min-Heap hat die Eigenschaft: Der kleinste Wert ist an der Wurzel.</li> <li>Ein Max-Heap hat die Eigenschaft: Der gr\u00f6\u00dfte Wert ist an der Wurzel.</li> </ul>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#heap-operationen","title":"Heap-Operationen","text":"<ul> <li>Einf\u00fcgen: Element wird am Ende eingef\u00fcgt und \u201enach oben geblubbert\u201c.</li> <li>Entfernen des Minimums: Wurzel entfernen, letztes Element nach oben setzen und \u201enach unten sinken\u201c.</li> </ul>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#warum-ist-die-suche-in-einem-heap-ineffizient","title":"Warum ist die Suche in einem Heap ineffizient?","text":"<p>In einem Heap gilt die Heap-Eigenschaft:</p> <ul> <li>Min-Heap: Eltern \u2264 Kinder</li> <li>Max-Heap: Eltern \u2265 Kinder</li> </ul> <p>Das bedeutet:</p> <ul> <li>Wir wissen nur, dass der Wurzelknoten der kleinste (Min-Heap) oder gr\u00f6\u00dfte (Max-Heap) ist.</li> <li>Aber wir wissen nicht, wie die anderen Elemente zueinander stehen.</li> <li>Keine vollst\u00e4ndige Sortierung \u2192 Wir k\u00f6nnen nicht gezielt links oder rechts gehen.</li> </ul>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#suchstrategien-im-heap","title":"Suchstrategien im Heap","text":"","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#methode-1-breitensuche-bfs","title":"Methode 1: Breitensuche (BFS)","text":"<ul> <li>Level f\u00fcr Level durchsuchen (wie eine Warteschlange).</li> <li>Gut, wenn die gesuchte Zahl nah an der Wurzel liegt.</li> </ul>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#methode-2-tiefensuche-dfs","title":"Methode 2: Tiefensuche (DFS)","text":"<ul> <li>Rekursiv nach links und rechts gehen.</li> <li>Praktisch, wenn der Baum gro\u00df ist.</li> </ul>","tags":["Course/"]},{"location":"studium/Algorithmen%20und%20Datenstruktur/1.%20Einf%C3%BChrung/#typische-anwendungsfalle","title":"Typische Anwendungsf\u00e4lle:","text":"<ol> <li> <p>Priorit\u00e4tswarteschlangen (Priority Queues):</p> <ul> <li>Wenn du Aufgaben nach ihrer Wichtigkeit verarbeiten willst.</li> <li>Beispiel: Betriebssysteme verwalten Prozesse mit unterschiedlichen Priorit\u00e4ten.<ul> <li>\u2192 Immer der h\u00f6chste Priorit\u00e4tsprozess l\u00e4uft zuerst (Min-/Max-Heap).</li> </ul> </li> </ul> </li> <li> <p>Dijkstra-Algorithmus (k\u00fcrzeste Wege in Graphen):</p> <ul> <li>Heap wird verwendet, um den n\u00e4chsten Knoten mit der k\u00fcrzesten Distanz schnell zu finden. Mit Min-Heap</li> <li>Ohne Heap w\u00e4re dieser Algorithmus viel langsamer.</li> </ul> </li> <li> <p>Heapsort (Sortieralgorithmus):</p> <ul> <li>Effizienter Sortieralgorithmus mit $O(n \\log n)$ Laufzeit.</li> <li>Besser als Bubble Sort oder Insertion Sort.</li> </ul> </li> <li> <p>Echtzeit-Systeme:</p> <ul> <li>Echtzeitspiele, Simulationen, Event-Handling \u2192 Aufgaben werden nach Priorit\u00e4t sortiert.</li> </ul> </li> <li> <p>Median-Findung (Streaming-Daten):</p> <ul> <li>Kombination aus Min-Heap und Max-Heap hilft, den Median von Datenstr\u00f6men effizient zu berechnen.</li> </ul> </li> </ol>","tags":["Course/"]},{"location":"studium/Betriebssysteme/1.%20Scheduling/Scheduling/","title":"Scheduling","text":"\ud83d\udcdd Infos - **Related to:** Course - **Date:** YYYY-MM-DD - **Professor/Speaker:** XYZ - **Tags:** CourseNote, Course"},{"location":"studium/Betriebssysteme/1.%20Scheduling/Scheduling/#scheduling","title":"\u2757\u2753 Scheduling","text":""},{"location":"studium/Betriebssysteme/1.%20Scheduling/Scheduling/#topic","title":"\u2757 Topic","text":""},{"location":"studium/Betriebssysteme/1.%20Scheduling/Scheduling/#resources","title":"\ud83d\udce6 Resources","text":""},{"location":"studium/Betriebssysteme/1.%20Scheduling/Scheduling/#key-points","title":"\ud83d\udd11 Key Points","text":""},{"location":"studium/Betriebssysteme/1.%20Scheduling/Scheduling/#questions","title":"\u2753 Questions","text":""},{"location":"studium/Betriebssysteme/1.%20Scheduling/Scheduling/#actions","title":"\ud83c\udfaf Actions","text":"<ul> <li>[ ] </li> <li>[ ] </li> <li>[ ] </li> <li>[ ] </li> <li>[ ] </li> </ul>"},{"location":"studium/Betriebssysteme/1.%20Scheduling/Scheduling/#summary-of-notes","title":"\ud83d\udcc3 Summary of Notes","text":""}]}