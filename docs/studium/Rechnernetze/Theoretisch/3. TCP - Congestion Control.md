---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Rechnernetze
tags:
  - Course/
---
## ðŸ”¹ **1. Grundlagen: TCP Congestion Control**

### <u>Wichtige Definitionen:</u>

| Begriff                     | ErklÃ¤rung                                                                                       |
| --------------------------- | ----------------------------------------------------------------------------------------------- |
| **ACK-Ankunft (An)**        | BestÃ¤tigt den Empfang aller Segmente bis einschlieÃŸlich `n`.                                    |
| **FlightSize 1**            | Anzahl noch nicht bestÃ¤tigter Pakete **nach Empfang** der ACKs.                                 |
| **FlightSize 2**            | Anzahl unbestÃ¤tigter Pakete **nach dem Senden** neuer Segmente.                                 |
| **DupACKs**                 | Anzahl **identischer ACKs**, die darauf hinweisen, dass ein Paket fehlt.                        |
| **ssthresh**                | Schwelle zwischen Slow Start und Congestion Avoidance.                                          |
| **cwnd**                    | GrÃ¶ÃŸe des Congestion Window (in Segmenten).                                                     |
| **Gesendete Segmente (Sn)** | Welche neuen Datenpakete verschickt wurden.                                                     |
| **CA-Segment**              | Segment, das in der Congestion Avoidance Phase verwendet wird, um den Fortschritt zu markieren. |
TCP (Transmission Control Protocol) ist ein verbindungsorientiertes Protokoll, das Mechanismen zur **Flusskontrolle** und **Ãœberlastkontrolle (Congestion Control)** verwendet. Die wichtigsten Phasen der TCP Congestion Control sind:
## ðŸ”¸ **1. Slow Start (langsamer Start, aber schnelles Wachstum)**

### â“Was ist das?

Die **Slow Start-Phase** ist die erste Phase im TCP Congestion Control-Mechanismus. Obwohl der Name "slow" klingt, wÃ¤chst das Fenster hier **exponentiell schnell**.

### âš™ï¸ Wie funktioniert das?

- TCP startet mit einem **kleinen Congestion Window (cwnd)**, z.â€¯B. 1 oder 3 Segmenten. In deiner Aufgabe: `cwnd = 3`.
- Jedes Mal, wenn ein vollstÃ¤ndiges Segment durch ein ACK bestÃ¤tigt wird, wird `cwnd` **um 1 erhÃ¶ht pro ACK** â†’ weil jedes ACK einen Hinweis gibt, dass die Verbindung stabil ist.
- Da mehrere ACKs in einem RTT eintreffen, **verdoppelt sich cwnd pro RTT** (exponentielles Wachstum):
    

#### ðŸ“ˆ Beispiel:

|RTT|Gesendete Segmente|empfangene ACKs|neuer cwnd|
|---|---|---|---|
|1|S1, S2, S3|ACK 4|6|
|2|S4-S9|ACK 10|12|
|3|S10-S21|ACK 21|...|

**FlightSize** = die Anzahl der gesendeten, aber **noch nicht bestÃ¤tigten** Segmente.

---

## ðŸ”¸ **2. ssthresh (Slow Start Threshold - Schwellenwert)**

### â“Was ist das?

`sâ€sthresh` ist der Schwellenwert, der **zwischen Slow Start und Congestion Avoidance** entscheidet.

- Initial: `ssthresh = âˆž` (also kein Ãœbergang â†’ Start in Slow Start).
- Wenn ein Verlust erkannt wird, wird `ssthresh` **gesetzt auf die HÃ¤lfte von `cwnd`**.
- Danach: Wenn `cwnd >= ssthresh`, dann wechselt TCP zur **Congestion Avoidance**.
    

#### ðŸ” Beispiel:

- `cwnd = 3`, `ssthresh = âˆž` â†’ TCP bleibt in Slow Start.
- Nach Verlust (z.â€¯B. Timeout), `ssthresh = â†’ 1`
- Dann beginnt TCP bei `cwnd = 1`, wÃ¤chst wieder.
    

---

## ðŸ”¸ **3. Congestion Avoidance (Stauvermeidung)**

### â“Was ist das?

In dieser Phase ist TCP vorsichtiger - **kein exponentielles Wachstum mehr**, sondern **lineares Wachstum**.

### âš™ï¸ Wie funktioniert das?

- Pro vollstÃ¤ndigem RTT erhÃ¶ht sich `cwnd` **nur um 1 Segment**.
- Motivation: Verbindung stabilisieren, ohne das Netz zu Ã¼berlasten.
    

#### ðŸ“ˆ Beispiel:

|RTT|cwnd vor ACK|ACKs erhalten|cwnd danach|
|---|---|---|---|
|5|10|ACKs fÃ¼r alle|11|
|6|11|ACKs|12|

Man spricht hier von **â€žAdditive Increaseâ€œ**.

---

## ðŸ”¸ **4. Verlust-Erkennung in TCP**

TCP erkennt Verluste **nicht direkt**, sondern **indirekt** Ã¼ber das Verhalten der ACKs.
- Kein ACK (auch keine DupACKs) â†’ Timeout â†’ cwnd wird zurÃ¼ckgesetzt â†’ RÃ¼ckkehr in Slow Start
	- Erkennt Timeout nach 10 RTT

- 3x DupACK â†’ Paketverlust vermutet â†’ Fast Retransmit + Fast Recovery â†’ Ãœbergang in Congestion Avoidance (kein Neustart)
	- Erkennt Package Loss wegen DUP ACK

---

### ðŸ›‘ **(a) Triple Duplicate ACKs - schnelles Eingreifen**

### â“Was ist das?

Wenn ein Segment fehlt, aber **darauffolgende Segmente ankommen**, sendet der EmpfÃ¤nger **wiederholt denselben ACK** (weil das letzte korrekt empfangene Segment noch nicht komplett bestÃ¤tigt wurde).

### âš™ï¸ Was passiert?

- Nach **3 gleichen (Duplikat-)ACKs** â†’ **Fast Retransmit**: Das vermisste Segment wird sofort neu gesendet.
- TCP vermutet: Netz ist leicht Ã¼berlastet â†’ reagiert moderat:
    

#### ðŸ“Œ Regel:

- `ssthresh = cwnd / 2`
- `cwnd = ssthresh + 3` â†’ â€žFast Recoveryâ€œ
- Dann geht es in Congestion Avoidance Ã¼ber (nicht zurÃ¼ck zu Slow Start).
    

#### ðŸ“¦ Beispiel:

1. S1-S6 werden gesendet.
2. S3 geht verloren.
3. EmpfÃ¤nger erhÃ¤lt S4-S6, aber hat S3 nicht â†’ sendet 3x `ACK3`.
4. Sender sieht 3 DupACKs â†’ **Fast Retransmit von S3**.
5. Setzt: `ssthresh = cwnd / 2`, `cwnd = ssthresh + 3`
    

---

### â±ï¸ **(b) Timeout (Retransmission Timeout - harter Verlust)**

### â“Was ist das?

Wenn ein ACK **gar nicht** ankommt (auch kein Duplicate ACK), nimmt TCP an: **Segment ging verloren UND kein Folgepaket kam durch**.

Das ist **schlimmer** als 3 DupACKs.

### âš™ï¸ Was passiert?

- Nach **10 RTTs ohne ACK** â†’ Timeout.
- TCP geht davon aus: **starke Ãœberlast**.
- Reaktion: **aggressiv reduzieren**

#### ðŸ“Œ Regel:

- `ssthresh = cwnd / 2`
- `cwnd = 1` â†’ zurÃ¼ck zu Slow Start
    

#### ðŸ“¦ Beispiel:
1. cwnd = 8 â†’ S1-S8 gesendet.
2. S5, S6, S7 verloren â†’ kein ACK mehr.
3. Nach 10 RTTs â†’ Timeout
4. Reaktion:
    
    - `ssthresh = 8 / 2 = 4`
    - `cwnd = 1`
        
5. TCP beginnt erneut mit Slow Start (exponentielles Wachstum ab 1).


ðŸŸ¢ **Aber**: Die Verbindung bleibt **offen** - TCP versucht weiter, **die bestehende Verbindung aufrechtzuerhalten**.

## ðŸ›‘ 2. **Wann wird die Verbindung endgÃ¼ltig beendet?**

TCP hat keine harte Regel wie â€ž1 Timeout â†’ Verbindung totâ€œ.  
ABER: Wenn **mehrere aufeinanderfolgende Timeouts** passieren und **auch dann keine Reaktion** vom EmpfÃ¤nger kommt, wird die Verbindung **irgendwann abgebrochen**.

### âš™ï¸ DafÃ¼r gibt es sogenannte:

- **Max Retransmission Count** oder
- **Maximum Segment Lifetime (MSL)** oder
- **Keepalive-Zeiten** (optional)
    

Wenn diese Schwellen Ã¼berschritten sind â†’ TCP schlieÃŸt die Verbindung mit einem **Reset (RST)** oder **Timeout-Abbruch**.

### âš™ï¸ **Was passiert bei 3 DupACKs - Schritt fÃ¼r Schritt**
| Schritt | ErklÃ¤rung                                                                                                         |
| ------- | ----------------------------------------------------------------------------------------------------------------- |
| 1       | TCP empfÃ¤ngt **3 DupACKs** fÃ¼r z.â€¯B. ACK 3                                                                        |
| 2       | **Fast Retransmit**: TCP sendet verlorenes Segment neu (z.â€¯B. S3)                                                 |
| 3       | **Fast Recovery beginnt**:â†’ `ssthresh = cwnd / 2`â†’ `cwnd = ssthresh + 3`                                          |
| 4       | FÃ¼r **weitere DupACKs** (z.â€¯B. ACK3, ACK3, â€¦): `cwnd += 1` pro DupACK (nur wenn sie kommen!)                      |
| 5       | Wenn ein **echtes ACK** die LÃ¼cke schlieÃŸt (z.â€¯B. ACK6):â†’ `cwnd = ssthresh`â†’ TCP geht in **Congestion Avoidance** |

> ðŸ“Œ **Wichtig**:  
> **Fast Retransmit + Fast Recovery** gehÃ¶ren **immer zusammen**  
> â†’ **"Fast Retransmit" ist die Aktion (sende Paket neu),  
> "Fast Recovery" ist die Reaktion (Fenster neu berechnen)**

| Ereignis      | Verhalten                                                           |
| ------------- | ------------------------------------------------------------------- |
| **3 DupACKs** | Fast Retransmit + Fast Recovery â†’ bleib in **Congestion Avoidance** |
| **Timeout**   | `ssthresh = cwnd / 2`, `cwnd = 1` â†’ zurÃ¼ck zu **Slow Start**        |
