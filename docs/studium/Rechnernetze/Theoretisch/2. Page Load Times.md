---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Rechnernetze
tags:
  - Course/
---
## ğŸ§  1. Was ist `cwnd`?

- **`cwnd` (Congestion Window)** ist ein interner Wert beim **Sender von TCP-Daten** (z.â€¯B. Webserver)
- Er regelt, **wie viele Bytes (bzw. Segmente)** TCP **auf einmal ins Netzwerk senden darf**, **ohne auf BestÃ¤tigungen (ACKs) zu warten.**
    

### Warum gibt es `cwnd`?

> Damit der Sender **nicht zu viele Daten auf einmal losschickt** und dadurch das **Netzwerk Ã¼berlastet**.

- TCP weiÃŸ nicht, **wo im Netz es gerade klemmt** (Router, Leitungen, etc.)
- Aber es merkt:
    
    - ğŸ“‰ Wenn ACKs **langsam oder gar nicht** zurÃ¼ckkommen â†’ âš ï¸ Stau â†’ **`cwnd` wird kleiner**
    - ğŸ“ˆ Wenn ACKs **schnell und vollstÃ¤ndig** zurÃ¼ckkommen â†’ ğŸŸ¢ alles gut â†’ **`cwnd` wird grÃ¶ÃŸer**
        

### cwnd wÃ¤chst bei:

- **ACKs**, die zurÃ¼ckkommen
- Je mehr ACKs, desto grÃ¶ÃŸer `cwnd` â†’ erlaubt mehr gleichzeitige Sendungen
    

### cwnd schrumpft bei:

- **Paketverlust** oder **Timeout**
- TCP wird vorsichtiger â†’ reduziert `cwnd`
    

---

## ğŸ”¢ 2. Was ist `IW` (Initial Window)?

- Das ist der **Startwert von `cwnd`**, wenn eine neue Verbindung aufgebaut wird.
- Beispiel: `IW = 2 MSS` â†’ TCP darf **direkt zu Beginn 2 Segmente** senden (z.â€¯B. 1600 Bytes bei MSS = 800 Bytes)

---

## ğŸ” 3. Was ist RTT (Round-Trip Time)?

- Die Zeit, die vergeht, **bis ein gesendetes Paket beantwortet wird**.
- Also:
    - ğŸ“¤ Ein Paket **geht raus**
    - ğŸ“¥ Eine Antwort (z.â€¯B. ACK oder Daten) **kommt zurÃ¼ck**  
        â†’ Das ist **eine RTT**

Beispiel:

- Client schickt HTTP-Request an Server
- Server schickt erste Antwort (z.â€¯B. ein Segment)  
    â†’ Das Ganze zÃ¤hlt als **1 RTT**

---

## ğŸ“¬ 4. Was sind ACKs?

- Das sind kleine Nachrichten vom **EmpfÃ¤nger an den Sender**, die sagen:
    > â€Ich habe dein Paket bekommen.â€œ

TCP wartet auf diese ACKs, um:

- **zu wissen, was angekommen ist**
- **zu entscheiden, ob `cwnd` erhÃ¶ht werden darf**

Ohne ACKs â†’ kein Wachstum von `cwnd`.

---

## ğŸŒ 5. Beobachtet `cwnd` nur das lokale Netz?

**Nein.**  
`cwnd` bezieht sich auf den **gesamten Pfad** zwischen Client und Server (Ende-zu-Ende).

- Es â€fÃ¼hltâ€œ Staus im Netz **nur Ã¼ber die RÃ¼ckmeldungen (ACKs)**
- Es kennt **keine Router oder Leitungen direkt**
- Es reagiert aber **auf Verluste, VerzÃ¶gerungen und Doppelte ACKs** als Zeichen: â€Irgendwo ist es zu vollâ€œ

---

## ğŸŒ 6. Unterschied HTTP mit und ohne Pipelining

| Feature   | Ohne Pipelining                | Mit Pipelining                                              |
| --------- | ------------------------------ | ----------------------------------------------------------- |
| Anfragen  | Eine nach der anderen          | Alle auf einmal                                             |
| Antworten | Erst Antwort 1, dann 2, dann 3 | Auch in Reihenfolge - aber alle Anfragen schon vorher raus  |
| Vorteil   | Einfach, gut steuerbar         | Schnellere Anfragen                                         |
| Nachteil  | Viele RTTs nÃ¶tig               | Head-of-Line-Blocking: Wenn eine Antwort hÃ¤ngt, hÃ¤ngen alle |

---

## ğŸ“¦ 7. Beispiel: Bild wird Ã¼bertragen (mit TCP)

1. Client fragt: â€Gib mir Bild 5â€œ
2. Server schaut auf sein `cwnd` - z.â€¯B. 2 MSS â†’ schickt 2 Segmente
3. Client bekommt sie â†’ schickt 2 ACKs
4. Server empfÃ¤ngt ACKs â†’ erhÃ¶ht `cwnd` â†’ darf z.â€¯B. 4 Segmente schicken
5. Das geht so weiter, bis das Bild komplett da ist
6. Wenn alles ankam â†’ keine neuen ACKs â†’ Ruhe

---

## ğŸ’¥ MerksÃ¤tze zum Mitnehmen

- `cwnd` lebt **beim Sender**
- `cwnd` = **Vertrauenslevel**, wie viel man schicken darf
- **ACKs sind die WÃ¤hrung fÃ¼r Vertrauen**
- **RTT = Anfrage + Antwort**
- **Bei ACKs wÃ¤chst `cwnd`** (Slow Start)
- **Bei RTT wÃ¤chst cwnd** (Congestion Avoidance)
- Kein explizites â€cwnd ist jetzt grÃ¶ÃŸerâ€œ-Paket - es passiert **intern**
- HTTP mit Pipelining = schneller, aber riskanter bei Problemen


---

## ğŸ’¥ Kleine Ãœbungsaufgabe

| Objekt        | Request Bytes | Request Segmente | Response Bytes | Response Segmente |
|---------------|----------------|-------------------|------------------|---------------------|
| HTML Code     | 1200           | 2                 | 2000            | 3                   |
| Bild 1        | 1600           | 2                 | 3200            | 4                   |
| Bild 2        | 3200           | 4                 | 800             | 1                   |
| Bild 3        | 4800           | 6                 | 8000            | 10                  |
| Bild 4        | 800            | 2                 | 30000           | 38                  |
| Bild 5        | 1200           | 2                 | 11600           | 15                  |
| Bild 6 - 14   | 800            | 1                 | 8000            | 10                  |
| Bild 15       | 800            | 1                 | 52000           | 65                  |
| Bild 16       | 800            | 1                 | 11200           | 14                  |
| Bild 17 - 27  | 800            | 1                 | 3200            | 4                   |

| Parameter | Wert       |
|-----------|------------|
| MSS       | 800 Bytes  |
| IW        | 2 MSS      |

### ğŸ“ Legende fÃ¼r folgende Beispiele:

- `MOReq[...]` = HTML Request
- `IO1Req[...]` = Bild-Request 1
- `MO:Sx-Sy` = Server-Antwort fÃ¼r HTML
- `IOx:Sx-Sy` = Server-Antwort fÃ¼r Bild x
- `ACK` = Quittung fÃ¼r empfangenes Segment
- `cwnd` = Congestion Window
## ğŸ”· **Persistent HTTP ohne Pipelining**
### ğŸ”¹ Regel 1: **Kein Pipelining** (HTTP-Verhalten)

- Der Client darf **nur einen Request gleichzeitig** senden.
- Erst **nachdem die vollstÃ¤ndige Antwort empfangen** wurde, sendet er den **nÃ¤chsten Request**.
- Es gibt **keine Ãœberschneidung** zwischen Request-Response-Zyklen.
    
### ğŸ”¹ Regel 2: **TCP mit Slow Start**

- Server startet mit `cwnd = IW = 2 MSS`
- Bei **jedem ACK**, das der Server bekommt, **erhÃ¶ht sich `cwnd` um 1 MSS**
- Wenn mehrere Segmente gesendet wurden, kÃ¶nnen mehrere ACKs ankommen â†’ schnelleres Wachstum

|RTT|Tx Client|cwnd Client|Client (Browser)|Server|cwnd Server|Tx Server|
|---|---|---|---|---|---|---|
|1|2 Segmente|2 MSS|`MOReq[1200]`|EmpfÃ¤ngt Req, sendet ACK|2 MSS|1x ACK, 2 Segmente (HTML 0-1599)|
|2|2x ACK|4 MSS|ACK fÃ¼r HTML-Segmente|ErhÃ¶ht cwnd, sendet rest HTML|4 MSS|1 Segment (HTML 1600-1999)|
|3|1x ACK + 2 Segmente|5 MSS|ACK + `IO1Req[1600]`|EmpfÃ¤ngt Req, sendet ACK|5 MSS|1x ACK, 4 Segmente (Bild 1)|
|4|4x ACK + 4 Segmente|11 MSS|ACK + `IO2Req[3200]`|EmpfÃ¤ngt Req, sendet ACK|9 MSS|1x ACK, 1 Segment (Bild 2)|
|5|1x ACK|12 MSS|ACK fÃ¼r Bild 2|ErhÃ¶ht cwnd|10 MSS|-|
[Zur Legende](#legende-fÃ¼r-folgende-beispiele)

---

## ğŸ”· **Persistent HTTP mit Pipelining**

### ğŸ”¹ Regel 1: **Pipelining erlaubt** (HTTP-Verhalten)

- Der Client kann **mehrere Requests hintereinander senden**, ohne auf Antworten zu warten.
- Die Reihenfolge der Antworten muss vom Server **korrekt eingehalten werden**.
- Effizienter, weil **mehr RTTs parallel genutzt werden kÃ¶nnen**.
    

### ğŸ”¹ Regel 2: **TCP mit Slow Start** (gleich wie oben)

- `cwnd` beginnt mit 2 MSS
- Bei **jedem ACK** wÃ¤chst `cwnd` um 1 MSS (solange keine Verluste auftreten)(Slow Start)
- Server nutzt `cwnd`, um **mehrere Segmente gleichzeitig zu senden**

|RTT|Tx Client|cwnd Client|Client (Browser)|Server|cwnd Server|Tx Server|
|---|---|---|---|---|---|---|
|1|2 Segmente|2 MSS|`MOReq[1200]`|EmpfÃ¤ngt Req, sendet ACK|2 MSS|1x ACK, 2 Segmente (HTML)|
|2|2x ACK + 8 Segmente|4 MSS|ACK + `IO1-IO3Req`|EmpfÃ¤ngt Req, sendet 3x ACK|4 MSS|3x ACK, 3 Segmente (HTML Ende + Bild 1)|
|3|-|4 MSS|-|ErhÃ¶ht cwnd, sendet rest Bild 1|5 MSS|1 Segment (Bild 1)|
|4|4x ACK|8 MSS|ACK fÃ¼r Bild 1|ErhÃ¶ht cwnd, sendet Bild 2|9 MSS|1 Segment (Bild 2)|
|5|1x ACK|9 MSS|ACK fÃ¼r Bild 2|ErhÃ¶ht cwnd, sendet Bild 3|10 MSS|10 Segmente (Bild 3)|
[Zur Legende](#legende-fÃ¼r-folgende-beispiele)

---

## ğŸ”¶ **Was passiert bei Paketverlust? (gilt fÃ¼r beide FÃ¤lle)**

### ğŸ“‰ Regel 3: **Verlusterkennung & Reaktion**

- Wenn ein Segment **verloren geht**, merkt der Client das daran, dass er **mehrmals denselben ACK** sendet
- Der Server erkennt den Verlust bei:
    
    - **3 doppelten ACKs** â†’ **Fast Retransmit**: Er sendet das verlorene Segment **sofort nochmal**
    - Dann: **Reduktion des cwnd**
        - z.â€¯B. `cwnd = cwnd / 2`
        - Wechsel in den **Congestion Avoidance-Modus**
    
    Beispiel:
**Stell dir vor, der Server sendet:**
```
Segment 0 (Bytes 0-799) âœ…
Segment 1 (Bytes 800-1599) âœ…
Segment 2 (Bytes 1600-2399) âŒ â† dieses geht verloren
Segment 3 (Bytes 2400-3199) âœ…
```

**Der Client bekommt:**
- Segment 0 â†’ sendet `ACK 800`
- Segment 1 â†’ sendet `ACK 1600`
- âŒ Segment 2 fehlt â†’ Client **wartet auf 1600-2399**
- Dann kommt Segment 3 (Bytes 2400-3199), aber **Segment 2 fehlt noch!**
### ğŸ“£ Jetzt passiert's:

Der Client **kann Segment 3 nicht verwenden**, solange Segment 2 fehlt.  
â†’ Also schickt er **nochmal einen ACK fÃ¼r 1600**  
â†’ und nochmal...  
â†’ und nochmal...

> ğŸ“Œ Diese **doppelten ACKs** fÃ¼r denselben Bytewert nennt man **Duplicate ACKs**.
## ğŸš¨ **Wann reagiert der Server?**

Wenn der Server **drei Duplicate ACKs** fÃ¼r denselben Wert sieht (z.â€¯B. 3Ã— `ACK 1600`), dann:
- **erkennt er, dass Segment 2 fehlt**
- â†’ **Fast Retransmit**: er sendet Segment 2 **sofort erneut**
- â†’ **Reduziert sein cwnd** (hÃ¤ufig auf die HÃ¤lfte)

- **Bild 5**
    - Request: 1200 Bytes â†’ **2 Segmente**
    - Response: 11600 Bytes â†’ **15 Segmente**
- MSS = **800 Bytes**
- Wir nehmen an: **Segment 7** (Bytes `5600-6399`) geht verloren
---

## ğŸ“¦ **Beispiel: Paketverlust bei Bild 5 (Segment 7 fehlt)**

| RTT | Tx Client                   | cwnd Client  | Client (Browser)                      | Server                                 | cwnd Server  | Tx Server                           |
| --- | --------------------------- | ------------ | ------------------------------------- | -------------------------------------- | ------------ | ----------------------------------- |
| 1   | `IO5Req[1200]` (2 Segmente) | z.â€¯B. 20 MSS | sendet Bild-Request                   | empfÃ¤ngt Request, sendet ACK           | z.â€¯B. 50 MSS | 1x ACK, sendet 15 Segmente (Bild 5) |
| ... |                             |              |                                       | âŒ **Segment 7** (Byte 5600-6399) fehlt |              |                                     |
| 2   | 1x DUP ACK (fÃ¼r Segment 6)  | 20 MSS       | empfÃ¤ngt Segment 6                    | -                                      | 50 MSS       | -                                   |
| 3   | 1x DUP-ACK (fÃ¼r Segment 6)  | 20 MSS       | empfÃ¤ngt Segment 6                    | -                                      | 50 MSS       | -                                   |
| 4   | 1x DUP-ACK (fÃ¼r Segment 6)  | 20 MSS       | empfÃ¤ngt Segment 2                    | ğŸ” **Fast Retransmit** wird ausgelÃ¶st  | 50 MSS       | Retransmit Segment 7                |
| 5   | 1x ACK                      | 21 MSS       | empfÃ¤ngt fehlendes Segment â†’ komplett | erhÃ¶ht cwnd                            | 51 MSS       | -                                   |

[Zur Legende](#legende-fÃ¼r-folgende-beispiele)

---

