---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Algorithmen-Datenstrukturen
tags:
  - Course/
---

# **Union Find**

## ğŸ“š **1ï¸âƒ£ Begriffe & Grundlagen**

1. **Menge (Set):**  
    Eine Gruppe von Elementen, die zusammengehÃ¶ren.  
    Beispiel: `{1, 2, 3}` ist eine Menge.
    
2. **Disjunkte Mengen:**  
    Mengen, die **keine gemeinsamen Elemente** haben.  
    Beispiel: `{1, 2}` und `{3, 4}` sind disjunkt.
    
3. **ReprÃ¤sentant (Root/Wurzel):**  
    Ein **"Leader"** der Menge.  
    Jeder Knoten zeigt (direkt oder indirekt) auf diesen ReprÃ¤sentanten.
    
4. **Union-Find (Disjoint-Set Union, DSU):**  
    Eine **Datenstruktur**, die hilft:
    - Zu prÃ¼fen, ob zwei Elemente in derselben Menge sind (`find`).
    - Zwei Mengen zu einer Menge zu vereinigen (`union`).
## ğŸ“ **Zusammenfassung der wichtigsten Punkte**

|**Begriff**|**Beschreibung**|
|---|---|
|**Union**|Verbindet zwei Mengen (macht einen gemeinsamen ReprÃ¤sentanten).|
|**Find**|Findet den ReprÃ¤sentanten (Wurzel) einer Menge.|
|**Rank**|SchÃ¤tzung der "Tiefe" des Baumes (hilft, die Struktur beim `union` flach zu halten).|
|**Path Compression**|Optimiert die `find`-Methode, indem alle Knoten direkt mit der Wurzel verbunden werden.|

---

## ğŸ” **2ï¸âƒ£ Operationen in Union-Find**

1. **`find(x)` - Finde den ReprÃ¤sentanten der Menge von `x`.**
    
    - Gibt den **"Root"** der Menge zurÃ¼ck, zu der `x` gehÃ¶rt.
    - Beispiel: In `{1 â†’ 2 â†’ 3}`, ist `3` der ReprÃ¤sentant von `1`.
2. **`union(x, y)` - Vereine die Mengen von `x` und `y`.**
    
    - Falls `x` und `y` in verschiedenen Mengen sind â†’ Vereine sie.
    - Nach `union(x, y)` haben beide Elemente **denselben ReprÃ¤sentanten**.

- **`union` (mit Rank):**
    
    - Bestimmt, **wie Mengen zusammengefÃ¼hrt werden**, um die Struktur **flach zu halten**.
    - **Flache BÃ¤ume** â†’ schnellere `find`-Operationen.
- **`find` (mit Path Compression):**
    
    - Optimiert die Struktur **nachtrÃ¤glich**, wenn wir nach einem ReprÃ¤sentanten suchen.
    - Macht den Baum **noch flacher**, indem **alle Knoten direkt mit der Wurzel verbunden** werden.


=== "ğŸ” Pseudo-Code-Unoptimiert"

    ```pseudo
	INITIALISIERE parent[x] = x fÃ¼r jedes x
	
	FUNKTION find(x):
	    WENN parent[x] == x:
	        GIB x zurÃ¼ck
	    ANDERNFALLS:
	        GIB find(parent[x]) zurÃ¼ck
	
	FUNKTION union(x, y):
	    rootX = find(x)
	    rootY = find(y)
	    WENN rootX != rootY:
	        parent[rootY] = rootX  // Mache rootY zum Kind von rootX
    ```

=== "ğŸ“ Pseudo-Code-Optimiert(Rank, Path Compression)"

    ```c
	INITIALISIERE parent[x] = x, rank[x] = 0 fÃ¼r jedes x
	
	FUNKTION find(x):
	    WENN parent[x] != x:
	        parent[x] = find(parent[x])  // Path Compression
	    GIB parent[x] zurÃ¼ck
	
	FUNKTION union(x, y):
	    rootX = find(x)
	    rootY = find(y)
	
	    WENN rootX == rootY:
	        GIB  // Schon in derselben Menge
	
	    WENN rank[rootX] < rank[rootY]:
	        parent[rootX] = rootY  // rootY bleibt Wurzel
	    ANDERNFALLS WENN rank[rootX] > rank[rootY]:
	        parent[rootY] = rootX  // rootX bleibt Wurzel
	    ANDERNFALLS:
	        parent[rootY] = rootX  // Einer wird Wurzel
	        rank[rootX] += 1       // Rank erhÃ¶hen
    ```

![[union_find.svg]]

### ğŸš€ **Fazit**

- âœ… **Union** verbindet zwei Mengen.
- âœ… **Find** findet den ReprÃ¤sentanten (Root) einer Menge.
- âœ… **Rank** sorgt dafÃ¼r, dass die BÃ¤ume flach bleiben.
- âœ… **Path Compression** macht die BÃ¤ume nachtrÃ¤glich noch flacher.
- âœ… **Optimierte Union-Find** ist extrem effizient: $O(\log n)$ bis $O(1)$ fÃ¼r `find` und `union`.


# **Kruskalâ€™s Algorithmus - Schritt-fÃ¼r-Schritt**


## ğŸ“š **Was ist das Ziel von Kruskalâ€™s Algorithmus?**

**Ziel:**

- Finde den **Minimalen Spannbaum (MST)** eines **gewichteten, ungerichteten Graphen**.
- Alle Knoten so gÃ¼nstig wie mÃ¶glich miteinander verbinden.

Ein **Minimaler Spannbaum (MST)**:

- **Verbindet alle Knoten** des Graphen.
- **Minimiert die Gesamtkosten** der Kanten (Summe der Kantengewichte).
- **Keine Zyklen** â†’ der MST ist ein **baumartiges** Netzwerk.

---

### ğŸ”‘ **WofÃ¼r ist das nÃ¼tzlich?**

- âœ… **Optimale Netzwerke:** Minimierung der LÃ¤nge von StraÃŸen, Kabeln, Netzwerken.
- âœ… **Kosteneinsparung:** Verbindungen herstellen, ohne unnÃ¶tige "teure" Kanten zu verwenden.
- âœ… **Effiziente Ressourcenverteilung:** Z.B. in Computernetzwerken, ElektrizitÃ¤tsnetzen, Transportnetzen.

### **Grundidee - Wie funktioniert:**

1. **Sortiere alle Kanten** nach ihrem Gewicht (aufsteigend).
2. **FÃ¼ge die leichteste Kante** zum MST hinzu, **sofern kein Zyklus entsteht**.
3. Wiederhole, bis der MST alle Knoten verbindet.

### ğŸš© **Wichtig:**

- Um **Zyklen zu vermeiden**, verwenden wir den **Union-Find-Algorithmus**.
- Wenn zwei Knoten **bereits im selben Set** sind â†’ **Kante nicht hinzufÃ¼gen** (wÃ¼rde einen Zyklus bilden).


## ğŸŒ **3ï¸âƒ£ Beispiel zur Veranschaulichung**

Stell dir vor, wir wollen **StÃ¤dte (A, B, C, D)** mit **Stromnetze** verbinden. Jedes Stromnetz hat **Kosten (Gewicht)**.
![[kruskal_algorithmus.svg]]

## **4ï¸âƒ£ Kruskalâ€™s Algorithmus - Schritt-fÃ¼r-Schritt**
### **Die zentrale Regel:**

- Elemente dÃ¼rfen nicht doppelt in dieselbe Menge aufgenommen werden sonst entsteht ein Zyklus

### âœ… **Schritt 1: Kantenliste aufstellen und sortieren (nach Gewicht)**

1. (A, C) = 1
2. (B, D) = 2
3. (A, D) = 3
4. (A, B) = 4
5. (C, D) = 5

---

### âœ… **Schritt 2: Kanten auswÃ¤hlen (kein Zyklus bilden)**

1ï¸âƒ£ **Kante (A, C) = 1**

- Verbinden â†’ Kein Zyklus â†’ **HinzufÃ¼gen**

2ï¸âƒ£ **Kante (B, D) = 2**

- Verbinden â†’ Kein Zyklus â†’ **HinzufÃ¼gen**

3ï¸âƒ£ **Kante (A, D) = 3**

- Verbinden â†’ Kein Zyklus â†’ **HinzufÃ¼gen**

4ï¸âƒ£ **Kante (A, B) = 4**

- **WÃ¼rde einen Zyklus bilden (A-D-B)** â†’ **Nicht hinzufÃ¼gen**

5ï¸âƒ£ **Kante (C, D) = 5**

- **WÃ¼rde einen Zyklus bilden (C-A-D)** â†’ **Nicht hinzufÃ¼gen**

---

## ğŸ† **Ergebnis:**

- **Minimaler Spannbaum (MST):**
    - Kanten: (A, C), (B, D), (A, D)
    - **Gesamtkosten:** 1 + 2 + 3 = **6**
### ğŸ“Š **6ï¸âƒ£ Vergleich: Mit und ohne Kruskal**

|**Ohne Kruskal (beliebige Verbindungen)**|**Mit Kruskal (MST)**|
|---|---|
|A-B = 4|A-C = 1|
|A-C = 1|B-D = 2|
|B-D = 2|A-D = 3|
|A-D = 3|**Gesamtkosten = 6**|
|C-D = 5||
|**Gesamtkosten = 15**||

- **Ohne Kruskal:** Wir kÃ¶nnten unnÃ¶tig teure Kanten verwenden.
- **Mit Kruskal:** Wir verwenden nur die **gÃ¼nstigsten Kanten**, um alle zu verbinden.