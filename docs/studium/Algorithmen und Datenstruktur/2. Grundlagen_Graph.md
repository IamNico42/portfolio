---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Algorithmen-Datenstrukturen
tags:
  - Course/
---

# **Graphen: Grundlagen**

Ein **Graph** ist eine mathematische Struktur, die aus:

- **Knoten (Vertices)** besteht, die Objekte repr√§sentieren,
- und **Kanten (Edges)**, die Verbindungen zwischen diesen Knoten darstellen.

Graphen werden verwendet, um Beziehungen zwischen Objekten zu modellieren, z.B. in **Netzwerken**, **Routenplanung**, **Datenbanken** oder **Sozialen Netzwerken**.

---

## **Arten von Graphen**

### **1.1. Gerichtet (Directed) vs. Ungerichtet (Undirected)**

- **Gerichteter Graph (Digraph):**
    
    - Die Kanten haben eine **Richtung** (Pfeile).
    - Eine Kante von A nach B ist **nicht** dasselbe wie von B nach A.
    - **Beispiel:** Verkehrsnetz (Einbahnstra√üen).

- **Ungerichteter Graph:**
    
    - Kanten haben **keine Richtung**.
    - Eine Kante verbindet Knoten **symmetrisch**: A ‚Üî B.
    - **Beispiel:** Freundschaften in sozialen Netzwerken.

---

### **1.2. Gewichteter (Weighted) vs. Ungewichteter (Unweighted)**

- **Gewichteter Graph:**
    
    - Jede Kante hat ein **Gewicht** (z.B. Kosten, Entfernung, Zeit).
    - Wird bei **k√ºrzesten Wegen** oder **Netzwerkoptimierungen** verwendet.

- **Ungewichteter Graph:**
    
    - Kanten sind einfach Verbindungen ohne zus√§tzliche Werte.
    - Gut f√ºr einfache Struktur-Analysen (z.B. Erreichbarkeit).

---

### **1.3. Zyklisch (Cyclic) vs. Azyklisch (Acyclic)**

- **Zyklischer Graph:**
    
    - Enth√§lt mindestens einen **Zyklus** (geschlossener Pfad).
    - **Beispiel:** Stromnetz, Stra√üennetze.
- **Azyklischer Graph (DAG - Directed Acyclic Graph):**
    
    - Enth√§lt **keinen Zyklus**.
    - **Wichtig f√ºr:** **Task-Planung**, **Versionskontrolle**, **Kompilierung von Abh√§ngigkeiten**.
- **Spezialfall:**
    
    - Ein **Baum** ist ein **ungerichteter, azyklischer, zusammenh√§ngender Graph**.

![[graph.svg]]

### **1.4. Adjazenzmatrix**

- Eine **Matrix AAA**, die angibt, ob zwei Knoten direkt verbunden sind.
    
- **F√ºr ungewichtete Graphen:**
    
    - $A[i][j]=1A[i][j] = 1A[i][j]=1$, wenn eine Kante von Knoten i nach j existiert.
    - $A[i][j]=0A[i][j] = 0A[i][j]=0$, wenn keine Verbindung besteht.
    
- **F√ºr gewichtete Graphen:**

    - Die Matrix speichert das **Gewicht** der Kante anstelle von 1.
    - Kein Pfad = **Unendlich (‚àû)** oder **0** (je nach Definition).
    
- **Speicherbedarf:**
    
    - **$O(V2)O(V^2)O(V2)$** ‚Üí Nicht effizient bei gro√üen, sp√§rlichen Graphen.
    - **Vorteil:** Schneller Zugriff auf Kanten: $O(1)O(1)O(1)$.

- **Beispiel:**
    

F√ºr Knoten {A, B, C} mit Kanten A-B, B-C:

### **Adjazenzmatrix (ungewichtet)**

|     | A   | B   | C   |
| --- | --- | --- | --- |
| A   | 0   | 1   | 0   |
| B   | 1   | 0   | 1   |
| C   | 0   | 1   | 0   |


### **Adjazenzmatrix (gewichteter, gerichteter Graph)**

- **Gerichteter Graph:** Die Matrix ist **nicht symmetrisch**.
- **Gewichtete Kanten:** Zahlen repr√§sentieren die Kosten/Entfernungen.
- **Unverbundene Knoten:** Markiert mit **‚àû**.

|     | A   | B   | C   |
| --- | --- | --- | --- |
| A   | 0   | 4   | 2   |
| B   | ‚àû   | 0   | 5   |
| C   | 3   | ‚àû   | 0   |

---

### **1.5. Adjazenzliste**

- Jeder Knoten speichert eine **Liste seiner Nachbarn**.
    
- **Effizient f√ºr sp√§rliche Graphen** (wenige Kanten im Vergleich zu Knoten).
    
- **Speicherbedarf:**
    
    - **$O(V+E)O(V + E)O(V+E)$** ‚Üí Spart Speicher bei gro√üen Netzwerken.
- **Vorteil:**
    
    - **Effizient** f√ºr Iteration √ºber Nachbarn.
    - **Nachteil:** Pr√ºfen, ob eine bestimmte Kante existiert, dauert $O(Grad)$.
- **Beispiel:**
    

F√ºr Knoten {A, B, C} mit Kanten A-B, B-C:
### üîó **Adjazenzliste**

| Knoten   | Knoten | Gewicht |
| -------- | ------ | ------- |
| A     ‚Üí  | B      | (5)     |
| B      ‚Üí | A,C    | (4)     |
| C      ‚Üí | B      | (3)     |

---
## **2.0 Graph-Traversierung**

#### **2.1. BFS (Breadth-First Search)**

BFS erkundet den Graphen **Schicht f√ºr Schicht (Level f√ºr Level)**.  
Stell dir BFS wie eine **Welle** vor, die sich gleichm√§√üig ausbreitet.

- Durchl√§uft den Graphen **Level f√ºr Level** (Breite zuerst).
- Verwendet eine **Warteschlange (Queue)**.
- Gut f√ºr das Finden von **k√ºrzesten Wegen in ungewichteten Graphen**.

### üîë **BFS-Anwendungen:**

1. **K√ºrzeste Wege (in ungewichteten Graphen):**
    - BFS findet den **k√ºrzesten Weg** von der Startposition zu allen anderen Knoten.
2. **Zyklus-Erkennung (ungerichtete Graphen):**
    - Wenn ein besuchter Nachbar erneut erreicht wird ‚Üí Zyklus existiert.
3. **Bipartite Graphen pr√ºfen:**
    - BFS hilft festzustellen, ob der Graph **zweifach f√§rbbar** ist.
![[bfs.svg]]
---
#### **2.2. DFS (Depth-First Search)**

DFS erkundet den Graphen **so tief wie m√∂glich**, bevor es zu einem anderen Pfad zur√ºckkehrt.  
Stell dir DFS wie ein **Labyrinth** vor: Du gehst immer so tief wie m√∂glich in einen Gang hinein, bis du nicht mehr weiterkommst, und gehst dann zur√ºck.

- Geht **so tief wie m√∂glich** in den Graphen, bevor es zur√ºcktrackt.
- Verwendet einen **Stack** (oft rekursiv implementiert).
- N√ºtzlich f√ºr **Zyklus-Erkennung**, **Topologische Sortierung**, **Connected Components**.
### üîë **DFS-Anwendungen:**

1. **Tiefensuchb√§ume (DFS-Trees):**
    
    - Zeigt den Ablauf der Traversierung.
    - **R√ºckw√§rtskanten (Back Edges)** ‚Üí helfen, Zyklen zu erkennen.
2. **Zyklus-Erkennung:**
    
    - Falls ein besuchter Knoten erneut erreicht wird, existiert ein **Zyklus**.
3. **Artikulationspunkte (Critical Points):**
    
    - Knoten, deren Entfernung den Graphen in zwei Teile trennt.
    - Wichtig bei **Netzwerken** zur Erkennung von Schwachstellen.
![[dfs.svg]]
---

## **Bipartite Graphen: Erkennung mit BFS & DFS**

### **Was ist ein bipartiter Graph?**

Ein **bipartiter Graph** ist ein Graph, dessen Knoten in **zwei disjunkte Mengen** AAA und BBB aufgeteilt werden k√∂nnen, sodass **keine Kante** zwei Knoten derselben Menge verbindet.

- **Formell:** Ein Graph ist bipartit, wenn er **2-f√§rbbar** ist, d.h. man kann ihn mit **zwei Farben** so f√§rben, dass **keine zwei benachbarten Knoten dieselbe Farbe** haben.

## **Erkennung eines bipartiten Graphen**

### **Strategie: 2-F√§rbigkeit**

1. **F√§rbe den Startknoten** mit Farbe **0**.
2. **F√§rbe alle Nachbarn** mit der **anderen Farbe** (z.B. Farbe 1).
3. **F√§rbe deren Nachbarn** wieder mit der urspr√ºnglichen Farbe (Farbe 0).
4. **Widerspruch:**
    - Falls zwei **benachbarte Knoten dieselbe Farbe** haben ‚Üí **nicht bipartit**.
    - Falls die F√§rbung **ohne Konflikte** abgeschlossen werden kann ‚Üí **bipartit**.
     
  ![[bipartite.svg]]![[not_bipartite.svg]]

---

## üåê**Starke Zusammenhangskomponenten (Strongly Connected Components, SCCs)**

### **Definition:**

In einem **gerichteten Graphen** ist eine **starke Zusammenhangskomponente (SCC)** eine Teilmenge von Knoten, bei denen jeder Knoten **von jedem anderen erreichbar** ist.

### **Kosaraju‚Äôs Algorithmus (DFS-basiert):**

1. **F√ºhre DFS aus** und speichere die Abschlusszeiten der Knoten.
2. **Spiegle den Graphen** (drehe alle Kanten um).
3. **F√ºhre DFS erneut aus**, diesmal in der Reihenfolge der abnehmenden Abschlusszeiten.
4. Jeder DFS-Durchlauf ergibt eine **SCC**.

### ‚ö° **Anwendung:**

- **Netzwerk-Analyse**
- **Abh√§ngigkeits-Graphen** (z.B. bei Software-Paketen)