---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Algorithmen-Datenstrukturen
tags:
  - Course/
---

# **Algorithmen und Datenstruktur**

---
## Einf√ºhrung in Algorithmen und Datenstrukturen

Ein Algorithmus ist eine systematische Methode zur L√∂sung eines Problems in endlich vielen Schritten. Er kann als Rezept oder Anleitung verstanden werden.

Eine **Datenstruktur** ist eine M√∂glichkeit, Daten effizient zu speichern und zu organisieren.
 
---


## **üîç 2. Suchalgorithmen**

### **2.1 Lineare Suche**

- Die einfachste Methode zur Suche in einer Liste.
- Durchl√§uft alle Elemente nacheinander.
- Laufzeit: **O(n)** im Worst Case.

=== "üîç Pseudo-Code"

    ```pseudo
    FUNKTION lineare_suche(arr, ziel):
    F√úR jedes Element i in arr:
        WENN arr[i] == ziel:
            GIB i zur√ºck // Index des gesuchten Elements
        GIB -1 zur√ºck // Falls Element nicht gefunden
    ```

=== "üìù C-Code"

    ```c
    // Lineare Suche in einem Array
    // n=Array Size
    int lineare_suche(int arr[], int n, int ziel) {
        for (int i = 0; i < n; i++) {
            if (arr[i] == ziel)
                return i;  // Index des gefundenen Elements
        }
        return -1;  // Nicht gefunden
    }
    ```

=== "‚òï Java-Code"

    ```java
    // Lineare Suche in einem Array
    public static int lineareSuche(int[] arr, int ziel) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == ziel) {
                return i;  // Index des gefundenen Elements
            }
        }
        return -1;  // Nicht gefunden
    }
    ```

=== "üêç Python-Code"

    ```python
    # Lineare Suche in einer Liste
    def lineare_suche(arr, ziel):
        for i in range(len(arr)):
            if arr[i] == ziel:
                return i  # Index des gefundenen Elements
        return -1  # Nicht gefunden
    ```
    
![[portfolio/docs/images/Lineare_Search.svg.svg]]

---
### **2.2 Bin√§re Suche (Binary Search)**

- Funktioniert nur bei **sortierten Listen/Arrays**.
- Durchsucht die Liste durch **wiederholtes Halbieren** des Suchbereichs.
- **Laufzeit:** O(log‚Å°n)O(\log n)O(logn) im Worst Case (logarithmische Komplexit√§t).

=== "üîç Pseudo-Code"

    ```pseudo
	FUNKTION binaere_suche(arr, links, rechts, ziel):
	    W√ÑHREND links <= rechts:
	        mitte = (links + rechts) / 2
	        WENN arr[mitte] == ziel:
	            GIB mitte zur√ºck // Index des gesuchten Elements
	        SONST WENN arr[mitte] < ziel:
	            links = mitte + 1  // Suche im rechten Teil
	        SONST:
	            rechts = mitte - 1  // Suche im linken Teil
	    GIB -1 zur√ºck // Falls Element nicht gefunden

    ```

=== "üìù C-Code"

    ```c
	int binaere_suche(int arr[], int links, int rechts, int ziel) {
	    while (links <= rechts) {
	        int mitte = links + (rechts - links) / 2;
	
	        if (arr[mitte] == ziel)
	            return mitte;  // Element gefunden
	
	        if (arr[mitte] < ziel)
	            links = mitte + 1;  // Suche im rechten Teil
	        else
	            rechts = mitte - 1;  // Suche im linken Teil
	    }
	    return -1;  // Element nicht gefunden
	}

    ```

=== "‚òï Java-Code"

    ```java
	public class BinarySearch {
	    public static int binaereSuche(int[] arr, int ziel) {
	        int links = 0, rechts = arr.length - 1;
	
	        while (links <= rechts) {
	            int mitte = links + (rechts - links) / 2;
	
	            if (arr[mitte] == ziel)
	                return mitte;  // Element gefunden
	
	            if (arr[mitte] < ziel)
	                links = mitte + 1;  // Suche im rechten Teil
	            else
	                rechts = mitte - 1;  // Suche im linken Teil
	        }
	        return -1;  // Element nicht gefunden
	    }
    ```

=== "üêç Python-Code"

    ```python
	def binaere_suche(arr, ziel):
	    links, rechts = 0, len(arr) - 1
	
	    while links <= rechts:
	        mitte = (links + rechts) // 2
	
	        if arr[mitte] == ziel:
	            return mitte  # Element gefunden
	        elif arr[mitte] < ziel:
	            links = mitte + 1  # Suche im rechten Teil
	        else:
	            rechts = mitte - 1  # Suche im linken Teil
	
	    return -1  # Element nicht gefunden
	
	# Beispiel
	arr = [1, 3, 5, 7, 9, 11, 13]
	ziel = 7
	ergebnis = binaere_suche(arr, ziel)
	
	if ergebnis != -1:
	    print(f"Element gefunden an Index {ergebnis}")
	else:
	    print("Element nicht gefunden")
    ```
    
![[binary_search.svg]]

---
## **üóÉÔ∏è3.  Sortieralgorithmen**

### **3.1 Bubble Sort**

- Vergleicht benachbarte Elemente und vertauscht sie.
- Sehr ineffizient bei gro√üen Datenmengen: **O(n¬≤)** Laufzeit.

#### üî¢ **Schritt-f√ºr-Schritt**

1. Durchlaufe die Liste mehrfach.
2. Vergleiche benachbarte Elemente.
3. Tausche sie, falls das linke gr√∂√üer ist als das rechte.
4. Wiederholen, bis keine Vertauschung mehr n√∂tig ist.
=== "üîç Pseudo-Code"

    ```pseudo
    FUNKTION bubble_sort(arr):
    F√úR i von 0 bis L√§nge(arr) - 1:
        F√úR j von 0 bis L√§nge(arr) - i - 1:
            WENN arr[j] > arr[j+1]:
                TAUSCHE arr[j] und arr[j+1]
    ```

=== "üìù C-Code"

    ```c
	void bubble_sort(int arr[], int n) { 
	    for (int i = 0; i < n - 1; i++) {
	        for (int j = 0; j < n - i - 1; j++) {
	            if (arr[j] > arr[j + 1]) {
	                // Elemente tauschen
	                int temp = arr[j];
	                arr[j] = arr[j + 1];
	                arr[j + 1] = temp;
	            }
	        }
	    }
	}
    ```

=== "‚òï Java-Code"

    ```java
    // Bubble Sort in Java
	public static void bubbleSort(int[] arr) {
	    int n = arr.length;
	    for (int i = 0; i < n - 1; i++) {
	        for (int j = 0; j < n - i - 1; j++) {
	            if (arr[j] > arr[j + 1]) {
	                // Elemente tauschen
	                int temp = arr[j];
	                arr[j] = arr[j + 1];
	                arr[j + 1] = temp;
	            }
	        }
	    }
	}
    ```

=== "üêç Python-Code"

    ```python
    # Bubble Sort in Python
	def bubble_sort(arr):
	    n = len(arr)
	    for i in range(n):
	        for j in range(0, n - i - 1):
	            if arr[j] > arr[j + 1]:
	                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    ```

![[bubblesort.svg]]

---

### **3.2 Quicksort**

- Ein effizienter **Divide & Conquer** Algorithmus.
- W√§hlt ein **Pivot-Element**, partitioniert die Liste und sortiert rekursiv.
- Laufzeit: **O(n log n)** im Durchschnitt.

### üöÄ **Schritt-f√ºr-Schritt**

1. W√§hle ein Pivot-Element (z. B. das letzte Element).
2. Partitioniere die Liste:
    - Elemente **kleiner** als Pivot.
    - Das **Pivot-Element**.
    - Elemente **gr√∂√üer** als Pivot.
3. Rufe Quicksort rekursiv f√ºr die beiden Partitionen auf.
=== "üîç Pseudo-Code"

    ```pseudo
    FUNKTION quicksort(arr, low, high):
    WENN low < high:
        pivot = PARTITION(arr, low, high)
        quicksort(arr, low, pivot - 1)
        quicksort(arr, pivot + 1, high)

    ```

=== "üìù C-Code"

    ```c
	#include <stdio.h>

	void swap(int *a, int *b) {
	    int temp = *a;
	    *a = *b;
	    *b = temp;
	}
	
	int partition(int arr[], int low, int high) {
	    int pivot = arr[high];
	    int i = (low - 1);
	    for (int j = low; j < high; j++) {
	        if (arr[j] < pivot) {
	            i++;
	            swap(&arr[i], &arr[j]);
	        }
	    }
	    swap(&arr[i + 1], &arr[high]);
	    return (i + 1);
	}
	
	void quicksort(int arr[], int low, int high) {
	    if (low < high) {
	        int pi = partition(arr, low, high);
	        quicksort(arr, low, pi - 1);
	        quicksort(arr, pi + 1, high);
	    }
	}
    ```

=== "‚òï Java-Code"

    ```java
    public static void quicksort(int[] arr, int low, int high) {
	    if (low < high) {
	        int pi = partition(arr, low, high);
	        quicksort(arr, low, pi - 1);
	        quicksort(arr, pi + 1, high);
	    }
	}
	
	private static int partition(int[] arr, int low, int high) {
	    int pivot = arr[high];
	    int i = (low - 1);
	    for (int j = low; j < high; j++) {
	        if (arr[j] < pivot) {
	            i++;
	            int temp = arr[i];
	            arr[i] = arr[j];
	            arr[j] = temp;
	        }
	    }
	    int temp = arr[i + 1];
	    arr[i + 1] = arr[high];
	    arr[high] = temp;
	    return i + 1;
	}
    ```
    

=== "üêç Python-Code"

    ```python
    # Bubble Sort in Python
	def bubble_sort(arr):
	    n = len(arr)
	    for i in range(n):
	        for j in range(0, n - i - 1):
	            if arr[j] > arr[j + 1]:
	                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    ```
In unserem grafischen Beispiel:
``Pivot = Array[Array size / 2]``
![[quicksort.svg]]

---
## üå≥ **4. B√§ume**

Ein **Baum** ist eine hierarchische Datenstruktur mit Knoten.  
Der oberste Knoten wird als **Wurzel** bezeichnet.

### **4.1 Bin√§re Suchb√§ume (BST)**

- Jeder Knoten hat **h√∂chstens zwei Kinder**.
- Linkes Kind: **kleiner** als der Elternknoten.
- Rechtes Kind: **gr√∂√üer** als der Elternknoten.
- Effizient f√ºr **Suchen, Einf√ºgen, L√∂schen**: **O(log n)**.

#### üå± **Einf√ºgen in einen BST**

1. **Leerer Baum:** Das Element wird die Wurzel.
2. **Wert < Knoten:** Gehe nach links.
3. **Wert > Knoten:** Gehe nach rechts.
4. **Finde die richtige Position und f√ºge ein.**


=== "üîç Pseudo-Code"

    ```pseudo
	FUNKTION einfuegen(knoten, wert):
	    WENN knoten == NULL:
	        GIB neuen Knoten(wert) zur√ºck
	    WENN wert < knoten.wert:
	        knoten.links = einfuegen(knoten.links, wert)
	    ANDERNFALLS:
	        knoten.rechts = einfuegen(knoten.rechts, wert)
	    GIB knoten zur√ºck
    ```

=== "üìù C-Code"

    ```c
	#include <stdio.h>
	#include <stdlib.h>
	
	struct Node {
	    int data;
	    struct Node* left;
	    struct Node* right;
	};
	
	struct Node* newNode(int data) {
	    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
	    node->data = data;
	    node->left = node->right = NULL;
	    return node;
	}
	
	struct Node* insert(struct Node* root, int data) {
	    if (root == NULL) return newNode(data);
	    if (data < root->data)
	        root->left = insert(root->left, data);
	    else
	        root->right = insert(root->right, data);
	    return root;
	}

    ```

=== "‚òï Java-Code"

    ```java
	class Node {
	    int data;
	    Node left, right;
	
	    public Node(int item) {
	        data = item;
	        left = right = null;
	    }
	}
	
	public Node insert(Node root, int data) {
	    if (root == null) {
	        root = new Node(data);
	        return root;
	    }
	    if (data < root.data)
	        root.left = insert(root.left, data);
	    else
	        root.right = insert(root.right, data);
	    return root;
	}

    ```

=== "üêç Python-Code"

    ```python
	class Node:
	    def __init__(self, data):
	        self.data = data
	        self.left = None
	        self.right = None
	
	def insert(root, data):
	    if root is None:
	        return Node(data)
	    if data < root.data:
	        root.left = insert(root.left, data)
	    else:
	        root.right = insert(root.right, data)
	    return root

    ```

![[binary_search_tree.svg]]

---
## **üóÉÔ∏è 5. Heaps und Priorit√§tswarteschlangen**

Ein **Heap** ist eine spezielle Bin√§rbaum-Datenstruktur:

- Ein **Min-Heap** hat die Eigenschaft: Der kleinste Wert ist an der Wurzel.
- Ein **Max-Heap** hat die Eigenschaft: Der gr√∂√üte Wert ist an der Wurzel.
### **Heap-Operationen**

- **Einf√ºgen**: Element wird am Ende eingef√ºgt und ‚Äûnach oben geblubbert‚Äú.
- **Entfernen des Minimums**: Wurzel entfernen, letztes Element nach oben setzen und ‚Äûnach unten sinken‚Äú.

### **Max-Heap (Einf√ºgen und Entfernen)**

- **Eigenschaften:**
    - Vollst√§ndiger Bin√§rbaum (alle Ebenen sind vollst√§ndig gef√ºllt, au√üer evtl. der letzten).
    - Elternknoten ist **gr√∂√üer oder gleich** seinen Kindknoten (Max-Heap-Eigenschaft).

####  **Schritt-f√ºr-Schritt: Einf√ºgen in einen Max-Heap**

1. F√ºge das neue Element am **Ende** des Heaps ein.
2. **"Heapify Up"**: Vergleiche das Element mit seinem Elternknoten.
3. Falls es **gr√∂√üer** ist, tausche die beiden. **kleiner** bei **Min-Heap**
4. Wiederholen, bis die Max-Heap-Eigenschaft erf√ºllt ist.

## **Warum ist die Suche in einem Heap ineffizient?**

In einem Heap gilt die **Heap-Eigenschaft**:

- **Min-Heap:** Eltern ‚â§ Kinder
- **Max-Heap:** Eltern ‚â• Kinder

Das bedeutet:

- **Wir wissen nur**, dass der **Wurzelknoten** der kleinste (Min-Heap) oder gr√∂√üte (Max-Heap) ist.
- **Aber wir wissen nicht**, wie die anderen Elemente zueinander stehen.
- **Keine vollst√§ndige Sortierung** ‚Üí Wir k√∂nnen **nicht gezielt links oder rechts** gehen.

## **Suchstrategien im Heap**

###  **Methode 1: Breitensuche (BFS)**

- **Level f√ºr Level** durchsuchen (wie eine Warteschlange).
- Gut, wenn die gesuchte Zahl nah an der Wurzel liegt.

###  **Methode 2: Tiefensuche (DFS)**

- **Rekursiv** nach links und rechts gehen.
- Praktisch, wenn der Baum gro√ü ist.

### **Typische Anwendungsf√§lle:**

1. **Priorit√§tswarteschlangen (Priority Queues):**
    - Wenn du Aufgaben nach ihrer **Wichtigkeit** verarbeiten willst.
    - Beispiel: **Betriebssysteme** verwalten Prozesse mit unterschiedlichen Priorit√§ten.
        - ‚Üí Immer der **h√∂chste Priorit√§tsprozess** l√§uft zuerst (Min-/Max-Heap).
    
2. **Dijkstra-Algorithmus (k√ºrzeste Wege in Graphen):**
    - Heap wird verwendet, um den **n√§chsten Knoten mit der k√ºrzesten Distanz** schnell zu finden. Mit **Min-Heap**
    - **Ohne Heap w√§re dieser Algorithmus viel langsamer.**
    
3. **Heapsort (Sortieralgorithmus):**
    - **Effizienter Sortieralgorithmus** mit $O(n \log n)$ Laufzeit.
    - Besser als Bubble Sort oder Insertion Sort.
    
4. **Echtzeit-Systeme:**
    - **Echtzeitspiele**, Simulationen, Event-Handling ‚Üí Aufgaben werden nach Priorit√§t sortiert.
    
5. **Median-Findung (Streaming-Daten):**
    - Kombination aus Min-Heap und Max-Heap hilft, den **Median von Datenstr√∂men** effizient zu berechnen.


=== "üîç Pseudo-Code"

    ```pseudo
	FUNKTION insert(heap, wert):
	    heap.F√úGE_HINZU(wert)
	    index = LETZTER_INDEX(heap)
	    W√ÑHREND index > 0 UND heap[ELTERN(index)] < heap[index]:
	        TAUSCHE heap[index] UND heap[ELTERN(index)]
	        index = ELTERN(index)

    ```

=== "üìù C-Code"

    ```c
	#include <stdio.h>
	
	// Hilfsfunktion zum Tauschen von zwei Elementen
	void swap(int *a, int *b) {
	    int temp = *a;
	    *a = *b;
	    *b = temp;
	}
	
	// "Heapify"-Funktion f√ºr einen Max-Heap
	void heapify(int arr[], int n, int i) {
	    int largest = i;       // Initialisiere das gr√∂√üte Element als Wurzel
	    int left = 2 * i + 1;  // Linkes Kind
	    int right = 2 * i + 2; // Rechtes Kind
	
	    // Vergleiche linkes Kind mit der Wurzel
	    if (left < n && arr[left] > arr[largest])
	        largest = left;
	
	    // Vergleiche rechtes Kind mit dem aktuell gr√∂√üten
	    if (right < n && arr[right] > arr[largest])
	        largest = right;
	
	    // Falls das gr√∂√üte Element nicht die Wurzel ist, tausche sie
	    if (largest != i) {
	        swap(&arr[i], &arr[largest]);
	        heapify(arr, n, largest); // Rekursiv heapify anwenden
	    }
	}
	
	// Heapsort-Algorithmus
	void heapsort(int arr[], int n) {
	    // Max-Heap erstellen
	    for (int i = n / 2 - 1; i >= 0; i--)
	        heapify(arr, n, i);
	
	    // Elemente sortieren
	    for (int i = n - 1; i >= 0; i--) {
	        swap(&arr[0], &arr[i]);  // Wurzel ans Ende verschieben
	        heapify(arr, i, 0);      // Heapify auf den reduzierten Heap anwenden
	    }
	}
	
	// Hilfsfunktion zum Drucken des Arrays
	void printArray(int arr[], int n) {
	    for (int i = 0; i < n; i++)
	        printf("%d ", arr[i]);
	    printf("\n");
	}
	
	int main() {
	    int arr[] = {4, 10, 3, 5, 1};
	    int n = sizeof(arr) / sizeof(arr[0]);
	
	    heapsort(arr, n);
	
	    printf("Sortiertes Array: ");
	    printArray(arr, n);
	
	    return 0;
	}

    ```

=== "‚òï Java-Code"

    ```
	    public class HeapSort {
	
	    // Hilfsfunktion zum "Heapify"-Prozess
	    public static void heapify(int[] arr, int n, int i) {
	        int largest = i;           // Wurzel
	        int left = 2 * i + 1;      // Linkes Kind
	        int right = 2 * i + 2;     // Rechtes Kind
	
	        // Linkes Kind gr√∂√üer als Wurzel?
	        if (left < n && arr[left] > arr[largest])
	            largest = left;
	
	        // Rechtes Kind gr√∂√üer als das gr√∂√üte Element?
	        if (right < n && arr[right] > arr[largest])
	            largest = right;
	
	        // Falls das gr√∂√üte Element nicht die Wurzel ist, tauschen
	        if (largest != i) {
	            int temp = arr[i];
	            arr[i] = arr[largest];
	            arr[largest] = temp;
	
	            // Rekursives Heapify
	            heapify(arr, n, largest);
	        }
	    }
	
	    // Heapsort-Algorithmus
	    public static void heapSort(int[] arr) {
	        int n = arr.length;
	
	        // Max-Heap erstellen
	        for (int i = n / 2 - 1; i >= 0; i--)
	            heapify(arr, n, i);
	
	        // Heap sortieren
	        for (int i = n - 1; i > 0; i--) {
	            // Wurzel (gr√∂√ütes Element) ans Ende verschieben
	            int temp = arr[0];
	            arr[0] = arr[i];
	            arr[i] = temp;
	
	            // Heapify auf den verkleinerten Heap anwenden
	            heapify(arr, i, 0);
	        }
	    }
	
	    // Hilfsfunktion zum Ausgeben des Arrays
	    public static void printArray(int[] arr) {
	        for (int i : arr)
	            System.out.print(i + " ");
	        System.out.println();
	    }
	
	    public static void main(String[] args) {
	        int[] arr = {4, 10, 3, 5, 1};
	
	        heapSort(arr);
	
	        System.out.println("Sortiertes Array:");
	        printArray(arr);
	    }
	}
    ```

=== "üêç Python-Code"

    ```
		# Heapify-Funktion f√ºr einen Max-Heap
	def heapify(arr, n, i):
	    largest = i        # Wurzel
	    left = 2 * i + 1   # Linkes Kind
	    right = 2 * i + 2  # Rechtes Kind
	
	    # Linkes Kind gr√∂√üer als Wurzel?
	    if left < n and arr[left] > arr[largest]:
	        largest = left
	
	    # Rechtes Kind gr√∂√üer als das gr√∂√üte Element?
	    if right < n and arr[right] > arr[largest]:
	        largest = right
	
	    # Falls das gr√∂√üte Element nicht die Wurzel ist, tausche
	    if largest != i:
	        arr[i], arr[largest] = arr[largest], arr[i]
	        heapify(arr, n, largest)  # Rekursives Heapify
	
	# Heapsort-Algorithmus
	def heapsort(arr):
	    n = len(arr)
	
	    # Max-Heap erstellen
	    for i in range(n // 2 - 1, -1, -1):
	        heapify(arr, n, i)
	
	    # Heap sortieren
	    for i in range(n - 1, 0, -1):
	        arr[i], arr[0] = arr[0], arr[i]  # Wurzel ans Ende verschieben
	        heapify(arr, i, 0)
	
	# Test des Heapsort
	arr = [4, 10, 3, 5, 1]
	heapsort(arr)
	print("Sortiertes Array:", arr)
    ```

![[min_heap.svg]]