---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Algorithmen-Datenstrukturen
tags:
  - Course/
---
# **KÃ¼rzeste Weg - Algorithmen**
## ğŸš€ **Dijkstra-Algorithmus - KÃ¼rzeste Weg**

---

### ğŸ“š **1ï¸âƒ£ Was ist der Dijkstra-Algorithmus?**

Der **Dijkstra-Algorithmus** ist ein Algorithmus zur Berechnung des **kÃ¼rzesten Weges** von einem Startknoten zu allen anderen Knoten in einem **gewichteten Graphen** (mit nicht-negativen Kantengewichten).

- **Ziel:** Finde den **kÃ¼rzesten Weg** (minimales Gesamtkosten) von einem Startknoten zu allen anderen Knoten.
- **Wichtig:** Funktioniert **nur bei nicht-negativen Kantengewichten**.

---

### ğŸ”‘ **2ï¸âƒ£ Grundidee**

1. **Initialisierung:**
    
    - Setze die Distanz zum Startknoten = 0.
    - Setze die Distanzen zu allen anderen Knoten = âˆ (unendlich).
2. **Verarbeitung:**
    
    - WÃ¤hle den **Knoten mit der kleinsten bekannten Distanz** (z.B. mit einer PrioritÃ¤tswarteschlange/Heap).
    - **Aktualisiere** die Distanzen zu den Nachbarn, wenn ein **kÃ¼rzerer Weg** gefunden wird (Relaxation).
3. **Wiederholen:**
    
    - Markiere den aktuellen Knoten als **"besucht"** (fertig).
    - Wiederhole den Prozess fÃ¼r den nÃ¤chsten unbesuchten Knoten mit der kleinsten Distanz.
4. **Ende:**
    
    - Der Algorithmus stoppt, wenn **alle Knoten besucht** wurden.

=== "ğŸ” Pseudo-Code"

    ```pseudo
	DIJKSTRA(G, start):
	    DISTANZ[start] = 0
	    FÃœR alle anderen Knoten v:
	        DISTANZ[v] = âˆ
	
	    INITIALISIERE eine leere PrioritÃ¤tswarteschlange Q
	    FÃœGE start mit Distanz 0 in Q ein
	
	    WÃ„HREND Q nicht leer:
	        u = Knoten mit kleinster Distanz aus Q
	        MARKIERE u als besucht
	
	        FÃœR jeden Nachbarn v von u:
	            WENN (DISTANZ[u] + KOSTEN(u, v)) < DISTANZ[v]:
	                DISTANZ[v] = DISTANZ[u] + KOSTEN(u, v)
	                AKTUALISIERE v in Q
    ```
=== "ğŸ” C-Code(mit PrioritÃ¤tswarteschlange)"

    ```C
	#include <stdio.h>
	#include <limits.h>
	
	#define V 4  // Anzahl der Knoten
	#define INF INT_MAX
	
	// Funktion zur Suche des Knotens mit der kleinsten Distanz
	int minDistance(int dist[], int visited[]) {
	    int min = INF, min_index;
	    for (int v = 0; v < V; v++) {
	        if (visited[v] == 0 && dist[v] <= min) {
	            min = dist[v], min_index = v;
	        }
	    }
	    return min_index;
	}
	
	void dijkstra(int graph[V][V], int start) {
	    int dist[V];
	    int visited[V];
	
	    for (int i = 0; i < V; i++) {
	        dist[i] = INF;
	        visited[i] = 0;
	    }
	    dist[start] = 0;
	
	    for (int count = 0; count < V - 1; count++) {
	        int u = minDistance(dist, visited);
	        visited[u] = 1;
	
	        for (int v = 0; v < V; v++) {
	            if (!visited[v] && graph[u][v] &&
	                dist[u] != INF &&
	                dist[u] + graph[u][v] < dist[v]) {
	                dist[v] = dist[u] + graph[u][v];
	            }
	        }
	    }
	
	    printf("Knoten \t KÃ¼rzeste Distanz vom Start (%d)\n", start);
	    for (int i = 0; i < V; i++) {
	        printf("%d \t\t %d\n", i, dist[i]);
	    }
	}
	
	int main() {
	    int graph[V][V] = {
	        {0, 4, 1, 2},   // A (0)
	        {4, 0, 0, 5},   // B (1)
	        {1, 0, 0, 3},   // C (2)
	        {2, 5, 3, 0}    // D (3)
	    };
	
	    dijkstra(graph, 0);  // Startknoten A (Index 0)
	    return 0;
	}
    ```

### ğŸ—ºï¸ **3ï¸âƒ£ Beispielgraph**

![[dijakstra-algorithmus.svg]]
#### âœ… **Schritt-fÃ¼r-Schritt (Start bei A)**

##### ğŸ”¹ **Initialisierung:**

|**Knoten**|A (Start)|B|C|D|
|---|---|---|---|---|
|**Distanz**|**0**|âˆ|âˆ|âˆ|
|**VorgÃ¤nger**|-|-|-|-|

---

##### ğŸ”¹ **Iteration 1: Start bei A**

- **Nachbarn von A:**
    - (A â†’ B) = 4 â†’ **aktualisiere B: Distanz = 4**
    - (A â†’ C) = 1 â†’ **aktualisiere C: Distanz = 1**
    - (A â†’ D) = 2 â†’ **aktualisiere D: Distanz = 2**

|**Knoten**|A|B|C|D|
|---|---|---|---|---|
|**Distanz**|0|4|1|2|
|**VorgÃ¤nger**|-|A|A|A|

- **Markiere A als besucht.**

---

##### ğŸ”¹ **Iteration 2: WÃ¤hle den Knoten mit der kleinsten Distanz â†’ C**

- **Nachbarn von C:**
    
    - (C â†’ D) = 3
    - **PrÃ¼fen:** Distanz Ã¼ber C zu D = 1 + 3 = 4 â†’ **NICHT kÃ¼rzer** als aktueller Wert (2). â†’ **Keine Ã„nderung.**
- **Markiere C als besucht.**
    

---

##### ğŸ”¹ **Iteration 3: WÃ¤hle den Knoten mit der kleinsten Distanz â†’ D**

- **Nachbarn von D:**
    
    - (D â†’ B) = 5
    - **PrÃ¼fen:** Distanz Ã¼ber D zu B = 2 + 5 = 7 â†’ **NICHT kÃ¼rzer** als aktueller Wert (4). â†’ **Keine Ã„nderung.**
- **Markiere D als besucht.**
    

---

##### ğŸ”¹ **Iteration 4: WÃ¤hle den letzten unbesuchten Knoten â†’ B**

- Keine weiteren Updates notwendig.
    
- **Markiere B als besucht.**
    

---

##### ğŸ† **Endergebnis (kÃ¼rzeste Distanzen von A):**

|**Knoten**|A|B|C|D|
|---|---|---|---|---|
|**Distanz**|0|4|1|2|
|**VorgÃ¤nger**|-|A|A|A|

- **KÃ¼rzeste Wege:**
    - A â†’ B = 4 (direkt)
    - A â†’ C = 1 (direkt)
    - A â†’ D = 2 (direkt)

##  **Fazit - Dijkstra** 

- âœ… **Standard-Dijkstra:** Findet den kÃ¼rzesten Weg von einem Startknoten zu allen anderen.
- âœ… **Optimierter Dijkstra:** FÃ¼r einen bestimmten Zielknoten kann der Algorithmus abgebrochen werden, sobald das Ziel erreicht ist.
- âœ… **VorgÃ¤nger speichern:** ErmÃ¶glicht es, den exakten Pfad zu rekonstruieren.
- âœ… **Anwendungen:** Navigation, Netzwerke, Routenplanung.


---

## **Floyd-Warshall-Algorithmus - All-Pairs Shortest Path (APSP)**

---

### ğŸ“š **Was ist der Floyd-Warshall-Algorithmus?**

Der **Floyd-Warshall-Algorithmus** ist ein **dynamischer Programmieralgorithmus**, der die **kÃ¼rzesten Wege zwischen allen Knotenpaaren** in einem **gewichteten, gerichteten Graphen** findet.

- âœ… **All-Pairs Shortest Path (APSP):** Berechnet die **kÃ¼rzesten Distanzen fÃ¼r jedes Knotenpaar** (u,v)(u, v)(u,v).
- âœ… Funktioniert mit **positiven und negativen Kantengewichten**, solange **kein negativer Zyklus** vorhanden ist.
- âœ… **Ja, Zyklen sind erlaubt**, wenn sie helfen, den kÃ¼rzesten Weg zu finden.
- ğŸš© **Aber:** **Negative Zyklen** (Zyklen, deren Gesamtkantengewicht < 0) sind problematisch, weil man dann **unendlich oft im Kreis laufen kÃ¶nnte, um die Distanz weiter zu verringern**.
- âŒ **Nicht effizient fÃ¼r groÃŸe, spÃ¤rliche Graphen** (besser geeignet fÃ¼r **dichte Graphen**).

## ğŸ”‘ **2ï¸âƒ£ Grundidee**

- FÃ¼r jeden Knoten **`k`** im Graphen prÃ¼fen wir:  
    **"Ist der Weg von `i` nach `j` kÃ¼rzer, wenn ich Ã¼ber `k` gehe?"**
    
- **Formel (Transition):**
$$dist[i][j]=minâ¡(dist[i][j],dist[i][k]+dist[k][j])$$

- Das bedeutet:
    - **Entweder:** Wir behalten den aktuellen kÃ¼rzesten Weg von `i` nach `j`.
    - **Oder:** Wir nehmen den Umweg Ã¼ber `k`, wenn dieser kÃ¼rzer ist.


---

## ğŸ—ºï¸ **3ï¸âƒ£ Beispielgraph**


![[floyd-warshall-algorithmus-beispiel.svg]]

---

### âœ… **Initialisierung der Distanzmatrix**

- **Unendliche Distanz (INF = âˆ)** fÃ¼r nicht direkt verbundene Knoten.
- **0** fÃ¼r die Diagonale (Distanz von einem Knoten zu sich selbst).

$$
D^{(0)} =
\begin{bmatrix}
0 & 4 & 1 & \infty \\
\infty & 0 & \infty & 5 \\
\infty & \infty & 0 & 3 \\
\infty & \infty & \infty & 0
\end{bmatrix}
$$
---

### ğŸš€ **4ï¸âƒ£ Schritt-fÃ¼r-Schritt (Iteration Ã¼ber Knoten als Zwischenknoten)**

Wir iterieren Ã¼ber jeden Knoten k als **Zwischenknoten**:

---

#### ğŸ”¹ **Iteration 1: Knoten A als Zwischenknoten (k = 0)**

- **Keine kÃ¼rzeren Wege Ã¼ber A** â†’ Matrix bleibt gleich.

$$
D^{(1)} =
\begin{bmatrix}
0 & 4 & 1 & \infty \\
\infty & 0 & \infty & 5 \\
\infty & \infty & 0 & 3 \\
\infty & \infty & \infty & 0
\end{bmatrix}
$$
---

#### ğŸ”¹ **Iteration 2: Knoten B als Zwischenknoten (k = 1)**

- PrÃ¼fen, ob ein Weg von **A â†’ D** Ã¼ber B kÃ¼rzer ist:
    - A â†’ B + B â†’ D = 4 + 5 = 9
    - Bisher: A â†’ D = âˆ  
        âœ… **Update: A â†’ D = 9**

Aktualisierte Matrix:

$$
D^{(2)} =
\begin{bmatrix}
0 & 4 & 1 & 9 \\
\infty & 0 & \infty & 5 \\
\infty & \infty & 0 & 3 \\
\infty & \infty & \infty & 0
\end{bmatrix}
$$
---

#### ğŸ”¹ **Iteration 3: Knoten C als Zwischenknoten (k = 2)**

- PrÃ¼fen, ob der Weg von **A â†’ D** Ã¼ber C kÃ¼rzer ist:
    - A â†’ C + C â†’ D = 1 + 3 = 4
    - Bisher: A â†’ D = 9  
        âœ… **Update: A â†’ D = 4** (besser!)

Aktualisierte Matrix:   
#### ğŸ”¹ **Iteration 4: Knoten D als Zwischenknoten (k = 3)**

- **Keine weiteren Verbesserungen**, da D keine ausgehenden Kanten hat.

$$
D^{(4)} =
\begin{bmatrix}
0 & 4 & 1 & 4 \\
\infty & 0 & \infty & 5 \\
\infty & \infty & 0 & 3 \\
\infty & \infty & \infty & 0
\end{bmatrix}
$$
---

#### ğŸ† **5ï¸âƒ£ Endergebnis: KÃ¼rzeste Distanzen**

$$
D^{(4)} =
\begin{bmatrix}
0 & 4 & 1 & 4 \\
\infty & 0 & \infty & 5 \\
\infty & \infty & 0 & 3 \\
\infty & \infty & \infty & 0
\end{bmatrix}
$$

- **KÃ¼rzeste Wege:**
    - A â†’ B = 4
    - A â†’ C = 1
    - A â†’ D = 4 (Ã¼ber C)
    - B â†’ D = 5
    - C â†’ D = 3


## **Beide finden den kÃ¼rzesten Weg - aber fÃ¼r verschiedene Zwecke**

| **Kriterium**      | **Dijkstra-Algorithmus**                                             | **Floyd-Warshall-Algorithmus**                                       |
| ------------------ | -------------------------------------------------------------------- | -------------------------------------------------------------------- |
| **Zweck**          | KÃ¼rzeste Wege von einem Startknoten zu allen anderen (Single-Source) | KÃ¼rzeste Wege zwischen **allen Knotenpaaren** (All-Pairs)            |
| **Kantengewichte** | Nur **nicht-negative** Kantengewichte                                | **Negative Kantengewichte erlaubt**, aber **keine negativen Zyklen** |
| **Zyklen**         | Vermeidet Zyklen, da er den kÃ¼rzesten Weg direkt findet              | Zyklen **sind erlaubt**, wenn sie den Weg **verkÃ¼rzen**              |
| **Effizienz**      | Besser fÃ¼r **spÃ¤rliche Graphen**                                     | Besser fÃ¼r **dichte Graphen**                                        |
| **Laufzeit**       | O((V+E)logâ¡V)O((V + E) \log V)O((V+E)logV) (mit Heap)                | O(V3)O(V^3)O(V3)                                                     |
