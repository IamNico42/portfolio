---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Algorithmen-Datenstrukturen
tags:
  - Course/
---
# **TiefensuchbÃ¤ume (DFS-Trees) und ihre Anwendung**

Da wir gerade Ã¼ber Artikulationspunkte und BrÃ¼cken gesprochen haben, ist der nÃ¤chste logische Schritt, den **Tiefensuchbaum (DFS-Tree)** zu behandeln.  
Der **DFS-Tree** ist die Grundlage fÃ¼r viele Graph-Algorithmen, einschlieÃŸlich der Erkennung von Artikulationspunkten und BrÃ¼cken.

---

## ğŸ“š **1ï¸âƒ£ Was ist ein Tiefensuchbaum (DFS-Tree)?**

- Ein **Tiefensuchbaum** ist ein **Spanning Tree**, der entsteht, wenn man einen Graphen mit der **Depth-First Search (DFS)** durchlÃ¤uft.
- Jeder Knoten wird genau **einmal besucht**, und die Kanten, die benutzt werden, um den Graphen zu erkunden, bilden den **DFS-Tree**.

---

### âœ… **Wichtige Begriffe:**

1. **Tree Edge (Baumkante):**
    
    - Kanten, die im DFS verwendet werden, um einen **neuen Knoten** zu erreichen.
    - **Teil des DFS-Trees.**
2. **Back Edge (RÃ¼ckkante):**
    
    - Kanten, die einen Knoten mit einem **bereits besuchten Vorfahren** verbinden.
    - Sie zeigen, dass ein Zyklus im Graphen existiert.
3. **Forward Edge (VorwÃ¤rtskante):**
    
    - Kanten, die von einem Knoten zu einem **bereits besuchten Nachkommen** fÃ¼hren (nur in gerichteten Graphen relevant).
4. **Cross Edge (Quer-Kante):**
    
    - Verbindet zwei **nicht direkt verwandte Knoten** im DFS-Tree (z.B. zwei Knoten aus verschiedenen TeilbÃ¤umen).

---

## ğŸŒ **2ï¸âƒ£ Beispiel: DFS-Tree mit einem ungerichteten Graphen**

### **Graph:**

```
    A
   / \
  B   C
   \ / \
    D   E
```
Start bei **A**.

### âœ… **DFS-Traversierung (A â†’ B â†’ D â†’ C â†’ E):**

1. **Baumkanten (Tree Edges):**
    
    - A â†’ B
    - B â†’ D
    - D â†’ C
    - C â†’ E
2. **RÃ¼ckkante (Back Edge):**
    
    - C â†’ A (zurÃ¼ck zu einem Vorfahren)

### ğŸŒ³ **DFS-Tree (Spanning Tree):**

```
    A
   /
  B
   \
    D
     \
      C
       \
        E
```

## ğŸš© **3ï¸âƒ£ Anwendung des DFS-Trees: Artikulationspunkte & BrÃ¼cken**

### âœ… **Artikulationspunkte (Cut Vertices):**

- **Regel:** Ein Knoten ist ein Artikulationspunkt, wenn das Entfernen des Knotens den Graphen in getrennte Komponenten zerlegt.
    
- **In unserem Beispiel:**
    
    - **B und D** sind Artikulationspunkte.

### âœ… **BrÃ¼cken (Cut Edges):**

- **Regel:** Eine Kante ist eine BrÃ¼cke, wenn sie keinen Zyklus bildet.
    
- **In unserem Beispiel:**
    
    - **B-D** ist eine BrÃ¼cke.

## **4ï¸âƒ£ Low- und Discovery-Times (fÃ¼r DFS-Algorithmen)**

- **Discovery Time (`disc[]`):** Der Zeitpunkt, an dem ein Knoten zum ersten Mal besucht wird.
- **Low-Value (`low[]`):** Der **kleinste Discovery-Wert**, der von diesem Knoten oder Ã¼ber RÃ¼ckkanten erreicht werden kann.

### âœ… **Formeln:**

- FÃ¼r jeden Knoten `u`: $$low[u]=minâ¡(disc[u],disc[v],low[w])$$
    - `v` = Nachbar von `u` (falls RÃ¼ckkante)
    - `w` = Kind von `u` im DFS-Tree

=== "ğŸ” C-Code erzeugung DFS-Tree"
	```pseudo
	#include <stdio.h>
	#include <stdbool.h>
	
	#define MAX 100
	
	int time = 0;
	
	void DFS(int u, int graph[MAX][MAX], int n, bool visited[], int parent[]) {
	    visited[u] = true;
	    printf("Besucht: %d\n", u);
	
	    for (int v = 0; v < n; v++) {
	        if (graph[u][v]) {
	            if (!visited[v]) {
	                parent[v] = u;  // Baumkante
	                DFS(v, graph, n, visited, parent);
	            } else if (v != parent[u]) {
	                // RÃ¼ckkante gefunden
	                printf("RÃ¼ckkante: %d â†” %d\n", u, v);
	            }
	        }
	    }
	}
	
	void createDFSTree(int graph[MAX][MAX], int n, int start) {
	    bool visited[MAX] = {false};
	    int parent[MAX];
	
	    for (int i = 0; i < n; i++) {
	        parent[i] = -1;
	    }
	
	    printf("DFS-Tree:\n");
	    DFS(start, graph, n, visited, parent);
	
	    printf("\nBaumkanten:\n");
	    for (int i = 0; i < n; i++) {
	        if (parent[i] != -1) {
	            printf("%d - %d\n", parent[i], i);
	        }
	    }
	}
	
	int main() {
	    int n = 5;
	    int graph[MAX][MAX] = {
	        {0, 1, 1, 0, 0},
	        {1, 0, 1, 1, 0},
	        {1, 1, 0, 1, 1},
	        {0, 1, 1, 0, 1},
	        {0, 0, 1, 1, 0}
	    };
	
	    createDFSTree(graph, n, 0);  // Startknoten: 0
	
	    return 0;
	}
    ```

---
### âœ… **Beispiel-Graph:**

```
    0
   / \
  1   2
   \ / \
    3   4
```

### **Ausgabe:**

```
DFS-Tree:
Besucht: 0
Besucht: 1
Besucht: 3
Besucht: 2
Besucht: 4

Baumkanten:
0 - 1
1 - 3
3 - 2
2 - 4

RÃ¼ckkante: 2 â†” 0
RÃ¼ckkante: 2 â†” 1

```

---

## ğŸš€ **6ï¸âƒ£ Fazit**

- âœ… **DFS-Trees** sind die Basis fÃ¼r viele Algorithmen, z.B. zur Erkennung von **Artikulationspunkten** und **BrÃ¼cken**.
- âœ… **Tree Edges** und **Back Edges** sind entscheidend fÃ¼r die Struktur des DFS-Trees.
- âœ… **Low- und Discovery-Times** helfen, kritische Knoten und Kanten zu identifizieren.![[dfs.svg]]![[bfs.svg]]