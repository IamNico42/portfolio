---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
tags:
  - Course/
---
## **ğŸ“Œ EinfÃ¼hrung: Prozesse und Scheduling

ğŸ”¹ **Kapitel 4 â€“ Prozesse**

- Ein **Prozess** ist ein laufendes Programm mit einem eigenen Adressraum.
- Prozesse haben **ZustÃ¤nde**: **running, ready, waiting**.

ğŸ”¹ **Kapitel 5 â€“ Process API**

- Prozesse werden mit **`fork()`** erstellt und mit **`exec()`** ersetzt.
- `wait()` sorgt dafÃ¼r, dass ein Elternprozess auf sein Kind wartet.

ğŸ”¹ **Kapitel 6 â€“ Direct Execution**

- Ein Programm lÃ¤uft direkt auf der CPU, aber das Betriebssystem verwaltet den Zugriff auf Ressourcen Ã¼ber **System Calls**.

ğŸ”¹ **Kapitel 7 â€“ CPU Scheduling**

- **First-Come, First-Served (FCFS)** â†’ einfacher, aber unfair.
- **Round Robin (RR)** â†’ jeder Prozess erhÃ¤lt eine feste Zeitscheibe.
- **Shortest Job First (SJF)** â†’ optimale Wartezeiten, aber schwer vorherzusagen.

ğŸ”¹ **Kapitel 8 â€“ Multi-Level Feedback Queue (MLFQ)**

- Dynamisches Scheduling, das Prozesse priorisiert, die schnell reagieren mÃ¼ssen.

ğŸ”¹ **Kapitel 9 â€“ Lottery Scheduling**

- Threads erhalten **"Lottoscheine"**, und einer wird zufÃ¤llig zur AusfÃ¼hrung ausgewÃ¤hlt.

ğŸ”¹ **Kapitel 10 â€“ Multi-CPU Scheduling**

- Symmetrisches und asymmetrisches Multi-Prozessor-Scheduling.

ğŸ”¹ **Kapitel 11 â€“ Zusammenfassung der Scheduling-Strategien**

- Vergleich aller Scheduling-Algorithmen und deren Effizienz.

---

## **ğŸ“Œ Teil 2: Speicherverwaltung (Kapitel 12â€“24)**

ğŸ”¹ **Kapitel 12 â€“ AdressrÃ¤ume**

- Jeder Prozess hat seinen eigenen **virtuellen Adressraum** (Heap, Stack, Code, Data).

ğŸ”¹ **Kapitel 13 â€“ Address Spaces & Code**

- Trennung von **virtuellen und physischen Adressen**.
- OS verwaltet den Speicher mit **Paging oder Segmentierung**.

ğŸ”¹ **Kapitel 14 â€“ Memory API**

- **Heap-Management**: `malloc()`, `free()` und Speicherallokatoren.

ğŸ”¹ **Kapitel 15 â€“ Address Translation**

- **MMU (Memory Management Unit)** Ã¼bersetzt virtuelle in physische Adressen.

ğŸ”¹ **Kapitel 16 â€“ Segmentation**

- Speicher wird in **logische Segmente** unterteilt.
- **Problem**: Fragmentierung.

ğŸ”¹ **Kapitel 17 â€“ Free Space Management**

- **Buddy-System** & **Bitmap-Allokatoren** verwalten freien Speicherplatz.

ğŸ”¹ **Kapitel 18 â€“ EinfÃ¼hrung in Paging**

- **Paging** unterteilt den Speicher in **gleich groÃŸe Seiten**.
- Vorteile: Kein Fragmentierungsproblem wie bei Segmentierung.

ğŸ”¹ **Kapitel 19 â€“ Translation Lookaside Buffer (TLB)**

- **TLB (Translation Lookaside Buffer)** speichert hÃ¤ufig verwendete AdressÃ¼bersetzungen.

ğŸ”¹ **Kapitel 20 â€“ Fortgeschrittene Page Tables**

- **Multi-Level Page Tables** sparen Speicherplatz.
- **Inverted Page Tables** speichern nur verwendete Seiten.

ğŸ”¹ **Kapitel 21 â€“ Swapping: Mechanismen**

- **Swapping** lagert inaktive Prozesse auf die Festplatte aus.

ğŸ”¹ **Kapitel 22 â€“ Swapping: Policies**

- **Wann und wie oft** Prozesse geswappt werden, beeinflusst die Performance.

ğŸ”¹ **Kapitel 23 â€“ VollstÃ¤ndige VM-Systeme**

- Kombiniert **Paging, TLBs und Swapping** fÃ¼r ein effizientes Speichersystem.

ğŸ”¹ **Kapitel 24 â€“ Zusammenfassung der Speicherverwaltung**

- Vergleich von **Paging, Swapping und Segmentierung**.

---

## **ğŸ“Œ Teil 3: Concurrency & Synchronisation (Kapitel 25â€“34)**

ğŸ”¹ **Kapitel 25 â€“ EinfÃ¼hrung in Concurrency**

- Mehrere Threads kÃ¶nnen parallel laufen, mÃ¼ssen aber synchronisiert werden.

ğŸ”¹ **Kapitel 26 â€“ Thread API**

- **POSIX-Threads (`pthread`)** â†’ `pthread_create()`, `pthread_join()`.

ğŸ”¹ **Kapitel 27 â€“ Locks**

- **Mutexe (`pthread_mutex_lock`)** verhindern Race Conditions.

ğŸ”¹ **Kapitel 28 â€“ Locks mit Spinlocks**

- **Spin Locks** vermeiden teure Kontextwechsel, verbrauchen aber CPU-Zeit.

ğŸ”¹ **Kapitel 29 â€“ Gesperrte Datenstrukturen**

- **Fine-Grained Locking**: Mehrere Locks fÃ¼r verschiedene Teile der Datenstruktur.

ğŸ”¹ **Kapitel 30 â€“ Bedingungsvariablen**

- **`pthread_cond_wait()`** blockiert Threads, bis eine Bedingung erfÃ¼llt ist.

ğŸ”¹ **Kapitel 31 â€“ Semaphoren**

- **`sem_wait()`, `sem_post()`** kontrollieren den Zugriff auf mehrere Ressourcen.

ğŸ”¹ **Kapitel 32 â€“ Race Conditions & Bugs**

- Typische Fehler: **Deadlocks**, **Starvation**, **Lost Updates**.

ğŸ”¹ **Kapitel 33 â€“ Event-basierte Concurrency**

- Alternative zu Threads: **asynchrone Ereignisbehandlung**.

ğŸ”¹ **Kapitel 34 â€“ Zusammenfassung der Synchronisationstechniken**

- Vergleich: **Mutexe, Semaphoren, Bedingungsvariablen, Spinlocks**.


## ğŸ“Œ**Quellen**

[ğŸ”— O-STEP Book](https://pages.cs.wisc.edu/~remzi/OSTEP)