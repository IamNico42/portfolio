---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Betriebssysteme
tags:
  - Course/
---
# ğŸ—ï¸ **EinfÃ¼hrung in Concurrency**

## ğŸš€ **1. EinfÃ¼hrung in Concurrency**
Concurrency (NebenlÃ¤ufigkeit) bezeichnet die FÃ¤higkeit eines Systems, mehrere Aufgaben gleichzeitig auszufÃ¼hren. Moderne Betriebssysteme und Multi-Core-Prozessoren machen Concurrency zu einem wesentlichen Konzept.

### **Warum Concurrency?**
- **Effizienz**: Optimale Nutzung von CPU-Kernen.
- **ReaktionsfÃ¤higkeit**: ErhÃ¶ht die InteraktivitÃ¤t von Anwendungen.
- **Skalierbarkeit**: Bessere Performance auf Multi-Core-Systemen.

---

## ğŸ§µ **2. Threads: Grundlagen & API**
### **Was sind Threads?**
Ein Thread ist eine leichtgewichtige Untereinheit eines Prozesses. Mehrere Threads eines Prozesses teilen sich denselben Speicherraum.

### **Threads in verschiedenen Sprachen**

=== "ğŸ“ C-Code (POSIX Threads)"
	
	```c
	#include <pthread.h> 
	#include <stdio.h> 
	void* thread_function(void* arg) { 
		printf("Hello from thread!\\n"); return NULL; 
	} 
	int main() { 
		pthread_t thread; pthread_create(&thread, NULL, thread_function, NULL);
		pthread_join(thread, NULL); return 0; 
	}
	```

=== "â˜• Java-Code (Java Threads)"

	```java
	class MyThread extends Thread {
		public void run() {
			System.out.println("Hello from thread!");
		}
	}
	
	public class Main { 
		public static void main(String[] args) { 
			MyThread t = new MyThread(); t.start(); 
		} 
	}
	```

=== "ğŸ Python-Code (Threading Modul)"

	```python
	import threading
	
	def thread_function():
		print("Hello from thread!")
	
	thread = threading.Thread(target=thread_function)
	thread.start()
	thread.join()
	```

---

## âš ï¸ **3. Race Conditions & Synchronisation**
### **Race Condition**
Ein Race Condition tritt auf, wenn mehrere Threads gleichzeitig auf eine geteilte Ressource zugreifen und das Ergebnis von der Reihenfolge der Zugriffe abhÃ¤ngt.

#### **Beispiel einer Race Condition in C**
	```c
	#include <pthread.h>
	#include <stdio.h>
	
	int counter = 0;
	
	void* increment(void* arg) {
	    for (int i = 0; i < 100000; i++) {
	        counter++;  // ğŸ”´ Race Condition! !!FIX MIT LOCKS!!
	    }
	    return NULL;
	}
	
	int main() {
	    pthread_t t1, t2;
	    pthread_create(&t1, NULL, increment, NULL);
	    pthread_create(&t2, NULL, increment, NULL);
	    pthread_join(t1, NULL);
	    pthread_join(t2, NULL);
	    printf("Counter: %d\\n", counter);  // âŒ Inkonsistentes Ergebnis!
	    return 0;
	```

### **LÃ¶sung: Synchronisation mit Locks**

=== "ğŸ“ C-Code mit Mutex" 

	```c
	void* increment(void* arg) {
	    for (int i = 0; i < 100000; i++) {
	        pthread_mutex_lock(&lock);
	        counter++;
	        pthread_mutex_unlock(&lock);
	    }
	}
	```

=== "â˜• Java mit Synchronized"

	```java
	java class Counter { 
		private int count = 0;
		 
		public synchronized void increment() { 
			count++; 
		} 
	}
	```

=== "ğŸ Python mit Lock" 

	```python
	counter = 0
	lock = threading.Lock()
	
	def increment():
	    global counter
	    with lock:
	        counter += 1
	```

---
## ğŸ” **4. Locks, Semaphoren & Deadlocks**

### **ğŸ”’ Mutex (Mutual Exclusion)**

Ein Mutex erlaubt nur einem Thread den Zugriff auf eine kritische Sektion.

### **ğŸš¦ Semaphore**

Ein Semaphore begrenzt die Anzahl der Threads, die gleichzeitig auf eine Ressource zugreifen kÃ¶nnen.

#### **Beispiel eines Semaphores in C**

=== "ğŸ“ C-Code mit Mutex" 

	```c
		#include <semaphore.h>
		sem_t semaphore;
		
		void* worker(void* arg) {
		    sem_wait(&semaphore);  // Eintritt in kritische Sektion
		    printf("Thread in kritischer Sektion\\n");
		    sem_post(&semaphore);  // Verlassen der kritischen Sektion
		}
	```

### **ğŸ Deadlocks & Avoidance**

Ein **Deadlock** tritt auf, wenn zwei Threads auf Ressourcen warten, die der jeweils andere blockiert.

#### **Deadlock-Szenario**

1. **Thread A** hÃ¤lt **Lock 1**, wartet auf **Lock 2**.
2. **Thread B** hÃ¤lt **Lock 2**, wartet auf **Lock 1**.

LÃ¶sung:

- **Locking-Order:** Immer in der gleichen Reihenfolge sperren.
- **Deadlock-Erkennung:** OS kann zirkulÃ¤re WartezustÃ¤nde auflÃ¶sen.

## âš¡ **5. Thread-Kommunikation & Scheduling**

### **Thread-Scheduling**

- **Preemptive Scheduling**: OS kann Threads unterbrechen.
- **Cooperative Scheduling**: Threads geben die Kontrolle explizit zurÃ¼ck.

### **Bedingungsvariablen (Condition Variables)**

Erlauben es Threads, zu warten, bis eine Bedingung erfÃ¼llt ist.

#### **Beispiel in C mit `pthread_cond_t`**


```c
pthread_cond_t cond;
pthread_mutex_t lock;

void* producer(void* arg) {
    pthread_mutex_lock(&lock);
    pthread_cond_signal(&cond);  // Weckt einen wartenden Thread auf
    pthread_mutex_unlock(&lock);
}

```

## ğŸ› ï¸ **6. Debugging von Concurrency-Fehlern**

### **HÃ¤ufige Concurrency-Fehler**

- **Race Conditions** â†’ Verwenden von Locks/Semaphoren.
- **Deadlocks** â†’ Lock-Order festlegen.
- **Starvation** â†’ Fairness durch PrioritÃ¤tsregeln sicherstellen.

### **Tools fÃ¼r Debugging**

- **Valgrind (Helgrind) fÃ¼r C**: Erkennung von Race Conditions.
- **ThreadSanitizer fÃ¼r C++ & Rust**: Detektiert Data Races.
- **GDB fÃ¼r Threads**: Debugging auf niedriger Ebene.

## âœ… **7. Best Practices fÃ¼r Multi-Threaded-Programmierung**

### **ğŸ”¹ Best Practices**

âœ… Verwende **Mutexe** oder **Semaphoren**, um kritische Abschnitte zu schÃ¼tzen.  
âœ… Nutze **Thread-Pools**, um Performance zu optimieren.  
âœ… Setze **Atomic Operations** ein, wenn nur einfache Werte modifiziert werden mÃ¼ssen.  
âœ… Vermeide **zu viele Locks**, um **Deadlocks** zu verhindern.  
âœ… Nutze **Parallelisierungs-Patterns** wie **Map-Reduce** oder **Worker-Threads**.

---

## ğŸ“Œ **Fazit**

- Concurrency ist essenziell fÃ¼r moderne Software.
- Threads verbessern Performance, erfordern aber **Synchronisation**.
- Race Conditions und Deadlocks sind typische Probleme.
- Debugging-Tools helfen, Fehler frÃ¼hzeitig zu erkennen.
- **Gute Planung und Best Practices** sind entscheidend fÃ¼r stabile Programme.