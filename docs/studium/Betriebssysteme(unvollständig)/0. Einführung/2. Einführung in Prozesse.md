---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Betriebssysteme
tags:
  - Course/
---
#  **Process API - Erstellen und Verwalten von Prozessen**

---

## ğŸ“š **1ï¸âƒ£ Was ist ein Prozess?**

Ein **Prozess** ist eine **laufende Instanz eines Programms** mit eigenem **Speicherbereich** und **Registerzustand**.

ğŸ’¡ **Zwei MÃ¶glichkeiten zur Prozesserstellung:**

1. **Neuen Prozess von Grund auf erstellen**
    
    - Lade Code & Daten in den Speicher
    - Erstelle einen leeren Call Stack
    - Initialisiere den **Prozesskontrollblock (PCB)**
    - Setze den Prozess auf die **Ready-Queue**  
        âœ… Vorteil: Keine unnÃ¶tigen Kopien  
        âŒ Nachteil: Komplizierter einzurichten
2. **Vorhandenen Prozess klonen & anpassen**
    
    - **Unix fork()**: Erstellt eine exakte Kopie des Elternprozesses
    - **exec()**: Ersetzt den aktuellen Code durch ein anderes Programm  
        âœ… Vorteil: **Schnell** durch **Copy-on-Write (CoW)**  
        âŒ Nachteil: Erst Kopieren, dann Ãœberschreiben ist ineffizient

---

## ğŸ”„ **2ï¸âƒ£ Der `fork()` System Call - Prozesse duplizieren**

`fork()` erstellt eine exakte Kopie des laufenden Prozesses.

ğŸ“Œ **Wichtig:**

- Das Kind erhÃ¤lt **seine eigene Speicherzuweisung**.
- **Elternprozess bekommt die PID des Kindes, Kind bekommt `0`.**

ğŸ“Œ **Syntax in C:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    printf("Hallo Welt (pid:%d)\n", getpid());
    int rc = fork();
    if (rc < 0) {
        fprintf(stderr, "Fehler: fork() fehlgeschlagen\n");
        exit(1);
    } else if (rc == 0) {
        printf("Ich bin das Kind (pid:%d)\n", getpid());
    } else {
        printf("Ich bin der Elternprozess von %d (pid:%d)\n", rc, getpid());
    }
    return 0;
}

```


ğŸ’¡ **Ergebnis (nicht-deterministisch!):**



```c
Hallo Welt (pid:29146)  
Ich bin der Elternprozess von 29147 (pid:29146)  
Ich bin das Kind (pid:29147)  

```  

---

## â³ **3ï¸âƒ£ Der `wait()` System Call - Warten auf Kindprozesse**

`wait()` sorgt dafÃ¼r, dass ein Elternprozess auf das **Ende eines Kindprozesses** wartet.

ğŸ“Œ **Beispiel:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int rc = fork();
    if (rc < 0) {
        fprintf(stderr, "fork fehlgeschlagen\n");
        exit(1);
    } else if (rc == 0) {
        printf("Ich bin das Kind (pid:%d)\n", getpid());
        sleep(1);
    } else {
        int wc = wait(NULL);
        printf("Elternprozess von %d (wc:%d) (pid:%d)\n", rc, wc, getpid());
    }
    return 0;
}

```

âœ… **Ergebnis (deterministisch!):**


```c
Ich bin das Kind (pid:29267)  
Elternprozess von 29267 (wc:29267) (pid:29266)

```

ğŸ”¹ **Der Elternprozess wartet, bis das Kind beendet wurde.**

---

## ğŸƒâ€â™‚ï¸ **4ï¸âƒ£ Der `exec()` System Call - Ein anderes Programm starten**

Mit `exec()` kann ein Prozess ein anderes Programm ausfÃ¼hren, indem er sein eigenes ersetzt.

ğŸ“Œ **Beispiel:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int rc = fork();
    if (rc < 0) {
        fprintf(stderr, "fork fehlgeschlagen\n");
        exit(1);
    } else if (rc == 0) {
        char *args[] = {"ls", "-l", NULL};  // "ls -l" ausfÃ¼hren
        execvp(args[0], args);
        printf("Dies wird nicht mehr ausgefÃ¼hrt\n");
    } else {
        wait(NULL);
        printf("Elternprozess beendet\n");
    }
    return 0;
}

```

âœ… **ErklÃ¤rung:**

- **Elternprozess** bleibt gleich.
- **Kindprozess ersetzt sich selbst** mit `ls -l`.
- Falls `exec()` erfolgreich ist, lÃ¤uft der alte Code nicht weiter.

---

## ğŸ”ª **5ï¸âƒ£ `kill()` - Prozesse beenden**

Ein Prozess kann mit `kill(pid, SIGNAL)` ein anderes Programm beenden.

ğŸ“Œ **Beispiel:**
```c
#include <signal.h>
#include <unistd.h>

int main() {
    pid_t child = fork();
    if (child) {  
        sleep(5);
        kill(child, SIGKILL);
    } else {  
        while (1);  // Endlosschleife, bis es beendet wird
    }
    return 0;
}

```

âœ… **ErklÃ¤rung:**

- **Elternprozess wartet 5 Sekunden** und beendet das Kind dann mit `SIGKILL`.

---

## ğŸ”— **6ï¸âƒ£ Kommunikation zwischen Prozessen: `pipe()`**

Mit **Pipes** kÃ¶nnen Prozesse miteinander kommunizieren.

ğŸ“Œ **Beispiel:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int fd[2];  
    pipe(fd);
    pid_t child = fork();

    if (child == 0) {  // Kindprozess
        close(fd[1]);  // Schreibe-Ende schlieÃŸen
        char buffer[100];
        read(fd[0], buffer, 100);
        printf("Empfangene Nachricht: %s\n", buffer);
    } else {  // Elternprozess
        close(fd[0]);  // Lese-Ende schlieÃŸen
        char message[] = "Hallo, Kindprozess!";
        write(fd[1], message, sizeof(message));
        wait(NULL);
    }
    return 0;
}

```

âœ… **Ergebnis:**

```c
Empfangene Nachricht: Hallo, Kindprozess!

```

---

## ğŸš€ **7ï¸âƒ£ Fazit**

- `fork()` erstellt einen neuen Prozess.
- `wait()` sorgt fÃ¼r **synchronisierte AusfÃ¼hrung** zwischen Eltern und Kind.
- `exec()` **startet ein neues Programm im selben Prozess**.
- `kill()` kann Prozesse beenden.
- `pipe()` ermÃ¶glicht **Interprozesskommunikation**.

Diese System Calls sind das **Fundament jedes modernen Betriebssystems**! ğŸ”¥