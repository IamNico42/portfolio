---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Betriebssysteme
tags:
  - Course/
---
#  **Mechanism: Limited Direct Execution**

---

## ğŸ“š **1ï¸âƒ£ Ziel von CPU-Virtualisierung**

Das Ziel ist, **jeden Prozess so erscheinen zu lassen, als hÃ¤tte er die gesamte CPU fÃ¼r sich**.  
Da jedoch **mehrere Prozesse** gleichzeitig ausgefÃ¼hrt werden mÃ¼ssen, teilt das Betriebssystem die CPU durch **Zeitslicing (Time-Sharing)** auf.

**Herausforderungen:**

- **Performance**: Wie kann Virtualisierung effizient ohne Overhead implementiert werden?
- **Kontrolle**: Wie kann das OS Prozesse effizient ausfÃ¼hren, aber trotzdem die Kontrolle behalten?

---

## âš¡ **2ï¸âƒ£ Direkte AusfÃ¼hrung (Direct Execution)**

Beim direkten AusfÃ¼hren lÃ¤uft ein Benutzerprozess direkt auf der CPU:

1. Eintrag in die **Prozessliste** erstellen.
2. **Speicher zuweisen** und **Programm laden**.
3. **Register setzen**, dann `main()` aufrufen.
4. Prozess **lÃ¤uft direkt auf der CPU**.

ğŸ’¡ **Problem:**  
Ohne EinschrÃ¤nkungen kÃ¶nnte ein Prozess unkontrolliert laufen - das OS hÃ¤tte **keine Kontrolle** Ã¼ber CPU-Zeit oder kritische Systemressourcen.

---

## ğŸš¨ **3ï¸âƒ£ Probleme der direkten AusfÃ¼hrung**

### **Problem 1: GeschÃ¼tzte Operationen**

Was passiert, wenn ein Prozess eine **kritische Aktion** ausfÃ¼hren mÃ¶chte, z. B.:

- **I/O-Anfragen** an eine Festplatte senden?
- **Mehr Speicher oder CPU-Zeit** anfordern?

ğŸ”¹ **LÃ¶sung: GeschÃ¼tzter Kontrolltransfer**  
â†’ Es gibt **zwei Modi** fÃ¼r die CPU:

1. **User Mode:** Normale Programme kÃ¶nnen **nicht direkt auf Hardware zugreifen**.
2. **Kernel Mode:** Das Betriebssystem kann **alle Systemressourcen verwalten**.

ğŸ”¹ **Systemaufruf (System Call):**

- Benutzerprozesse kÃ¶nnen **keine direkten I/O-Operationen** ausfÃ¼hren.
- Stattdessen nutzen sie **System Calls** (`syscall`), um das OS um Erlaubnis zu bitten.

ğŸ’¡ **Ablauf eines System Calls:**

1. Der Benutzerprozess fÃ¼hrt eine **Trap-Instruktion** aus.
2. CPU wechselt in den **Kernel Mode**.
3. OS bearbeitet den **System Call** (z. B. Datei Ã¶ffnen).
4. CPU kehrt in den **User Mode** zurÃ¼ck.

ğŸ“Œ **Beispiel fÃ¼r einen System Call in C:**

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    write(1, "Hello, World!\n", 14); // System Call fÃ¼r die Ausgabe auf stdout
    return 0;
}

```

---

### **Problem 2: Prozesswechsel (Context Switch)**

Damit mehrere Prozesse gleichzeitig laufen kÃ¶nnen, muss das OS **zwischen Prozessen umschalten**.

ğŸ”¹ **LÃ¶sungen fÃ¼r CPU-Kontrolle:**

1. **Kooperativer Ansatz:**
    
    - Prozesse **geben freiwillig** die CPU ab (`yield` oder `sleep`).
    - Problem: Ein Prozess kann in einer **Endlosschleife hÃ¤ngen** â†’ System blockiert.
2. **Erzwungener Ansatz (Timer-Interrupts):**
    
    - Das OS startet einen **Timer**, der regelmÃ¤ÃŸig Interrupts auslÃ¶st.
    - Sobald der Timer ablÃ¤uft, wird die **aktuelle ProzessausfÃ¼hrung gestoppt**.
    - Das OS entscheidet, ob ein neuer Prozess gestartet wird.

ğŸ”¹ **Ablauf eines erzwungenen Prozesswechsels:**

1. **Timer lÃ¤uft ab â†’ Interrupt wird ausgelÃ¶st.**
2. **Der aktuelle Prozess wird unterbrochen.**
3. **Das OS speichert den aktuellen Zustand (Registersicherung).**
4. **Das OS wÃ¤hlt einen neuen Prozess.**
5. **Der neue Prozess wird geladen, und seine Register werden wiederhergestellt.**
6. **Der neue Prozess lÃ¤uft weiter.**

ğŸ“Œ **Beispiel fÃ¼r einen Timer-Interrupt in C (Linux Kernel)**

```c
void timer_interrupt_handler() {
    save_process_state(); // Zustand des aktuellen Prozesses sichern
    select_next_process(); // NÃ¤chsten Prozess auswÃ¤hlen
    restore_process_state(); // Zustand des neuen Prozesses laden
}

```

---

## ğŸ”„ **4ï¸âƒ£ Context Switch: Wechsel zwischen Prozessen**

Beim Wechsel zwischen Prozessen muss das OS sicherstellen, dass **keine Daten verloren gehen**.

ğŸ”¹ **Wichtige Schritte beim Context Switch:**

1. **Speichern des aktuellen Prozessstatus** (Register, Stack-Pointer).
2. **Wechsel in den Kernel Mode**.
3. **Laden des neuen Prozessstatus**.
4. **Wechsel zurÃ¼ck in den User Mode**.

ğŸ”¹ **Prozess hat zwei Stacks:**

- **User Stack:** Speichert lokale Variablen und RÃ¼cksprungadressen fÃ¼r **Benutzerprozesse**.
- **Kernel Stack:** Speichert Systemaufrufe und ProzesszustÃ¤nde fÃ¼r das **Betriebssystem**.

ğŸ’¡ **Prozesswechsel erfolgt Ã¼ber den â€Dispatcherâ€œ**, eine OS-Funktion, die Prozesse pausiert und neue lÃ¤dt.

ğŸ“Œ **Beispiel fÃ¼r Context Switch in Pseudo-Code:**

```
SAVE_CURRENT_PROCESS_STATE()
CHOOSE_NEXT_PROCESS()
RESTORE_PROCESS_STATE()
SWITCH_TO_USER_MODE()
```

---

## ğŸ¯ **5ï¸âƒ£ Fazit**

- **Direkte AusfÃ¼hrung ist effizient**, benÃ¶tigt aber Sicherheitsmechanismen.
- **Systemaufrufe ermÃ¶glichen kontrollierten Zugriff auf Hardware.**
- **Timer-Interrupts verhindern Endlosschleifen und CPU-Hogging.**
- **Context Switches sorgen fÃ¼r Multitasking und effiziente CPU-Nutzung.**

ğŸ’¡ **Ohne diese Mechanismen kÃ¶nnte ein einzelner Prozess das gesamte System Ã¼bernehmen!**

