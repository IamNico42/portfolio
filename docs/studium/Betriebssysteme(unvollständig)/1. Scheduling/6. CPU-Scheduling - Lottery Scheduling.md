---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Betriebssysteme
tags:
  - Course/
---
# **Proportional Share Scheduling (Fair Sharing)**

---
## ğŸ¯ **Was ist Proportional Share Scheduling?**

- Prozesse bekommen CPU-Zeit basierend auf einer **Gewichtung**.
- **Lotteriescheduling:** Jeder Prozess bekommt **Lose**, mehr Lose = hÃ¶here Wahrscheinlichkeit zu laufen.
- **Stridescheduling:** Prozesse haben eine **Schrittweite (Stride)** â†’ Der Prozess mit dem kleinsten "Passwert" lÃ¤uft zuerst.

## ğŸ“Œ **Lotteriescheduling**

- **Jeder Prozess erhÃ¤lt Lose**, dann wird **zufÃ¤llig gezogen**.
- **Fair:** Ãœber lange Zeit bekommt jeder ungefÃ¤hr die richtige CPU-Zeit.

=== "ğŸ” Pseudo-Code"

```python
while True:
    winner = random.choice(processes)  # ZufÃ¤llige Auswahl
    execute(winner)
```


---

### ğŸ“Œ **Stridescheduling**

- Prozesse haben eine **Schrittweite** â†’ Kleinerer Stride bedeutet, **hÃ¤ufiger** laufen.
- Ein Prozess mit 50% CPU-Zeit bekommt **doppelt so groÃŸe Schritte** wie einer mit 25%.

=== "ğŸ” Pseudo-Code"

```python
while True:
    process = min(queue, key=lambda p: p.pass_value)
    execute(process)
    process.pass_value += process.stride
```

---

## ğŸ”„ **Multiprozessor-Scheduling**

### ğŸ¯ **Problemstellung**

- Wie plant man Jobs auf **mehreren CPUs**?
- Kann ein Prozess **von einer CPU zur anderen wechseln**?
- Wie verhindert man **Lastungleichgewicht**?

### ğŸ“Œ **Single Queue Scheduling**

- **Eine Warteschlange fÃ¼r alle CPUs**.
- **Problem:** Hoher Synchronisationsaufwand.

---

### ğŸ“Œ **Multi-Queue Multiprozessor Scheduling (MQMS)**

- Jeder CPU-Kern bekommt **eigene Warteschlange**.
- **Geringere Synchronisationskosten** als Single Queue.
- **Problem:** **Lastungleichgewicht** â†’ Eine CPU kÃ¶nnte Ã¼berlastet sein.

=== "ğŸ” Pseudo-Code"

```python
while True:
    process = local_queue.pop(0)
    execute(process)
    if queue_empty:
        steal_work()
```


![[multiprocessor_scheduling.svg]]

---

### ğŸ“Œ **Load Balancing (Work Stealing)**

- Falls eine CPU **nichts zu tun hat**, **klaut sie Prozesse** von einer anderen CPU.

=== "ğŸ” Pseudo-Code"
```python
if local_queue.empty():
    target_cpu = find_busy_cpu()
    steal_process(target_cpu)
```


---

### ğŸ“Œ **Linux Multiprozessor Scheduling**

Linux verwendet mehrere Algorithmen fÃ¼r Multiprozessor-Systeme:

- **O(1) Scheduler:** Skalierbarer Scheduler mit **mehreren Warteschlangen**.
- **Completely Fair Scheduler (CFS):** Basiert auf **virtueller Zeit** â†’ Fairer als klassische Algorithmen.
- **Load Balancer:** Verteilt Prozesse **dynamisch** zwischen CPUs.

![[linux_sched.svg]]

---

## ğŸ† **Fazit**

1. **Einzel-CPU-Scheduling:**
    - FIFO, SJF, RR, MLFQ â†’ Jede hat Vor- und Nachteile.
2. **Fairness:**
    - Proportional Share Scheduling (Lotterie, Stride).
3. **Multiprozessor-Scheduling:**
    - **Single Queue:** Einfach, aber Synchronisationsprobleme.
    - **Multi-Queue:** Weniger Overhead, aber schwieriger zu balancieren.
    - **Work Stealing:** Dynamische Lastverteilung.
4. **Linux Scheduling:**
    - Kombination aus **prioritÃ¤tsbasiertem Scheduling** und **Lastverteilung**.