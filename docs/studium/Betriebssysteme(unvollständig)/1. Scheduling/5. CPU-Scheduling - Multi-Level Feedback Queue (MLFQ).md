---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Betriebssysteme
tags:
  - Course/
---
#  **Scheduling-Algorithmen**

---
### ğŸ”€ **First Come, First Served (FCFS)**

**Strategie:**

- Der **erste Prozess** bekommt die CPU und lÃ¤uft bis zum Ende.
- **Nicht-prÃ¤emptiv** â†’ Ein langer Job blockiert alle anderen!
- **Problem:** **Konvoi-Effekt** â†’ Schnelle Prozesse warten auf langsame.

=== "ğŸ” Pseudo-Code"


```python
queue = [P1, P2, P3]  # Prozesse in Ankunftsreihenfolge
while queue:
    process = queue.pop(0)  # NÃ¤chster Prozess wird gewÃ¤hlt
    execute(process)  # Prozess lÃ¤uft bis zum Ende
```

---

### ğŸ”€ **Shortest Job First (SJF)**

**Strategie:**

- Immer den Prozess mit der **kÃ¼rzesten verbleibenden Laufzeit** zuerst wÃ¤hlen.
- **Nicht-prÃ¤emptiv** (ein laufender Prozess wird nicht unterbrochen).
- **Problem:** **Starvation** â†’ Lange Prozesse kÃ¶nnen ewig warten!

=== "ğŸ” Pseudo-Code"

```python
while jobs:
    shortest_job = min(jobs, key=lambda x: x.runtime)
    execute(shortest_job)
```

---

### ğŸ”€ **Round Robin (RR)**

**Strategie:**

- Jeder Prozess bekommt einen **Zeitslot (z. B. 50ms)**, dann wird **zum nÃ¤chsten gewechselt**.
- **PrÃ¤emptiv** â†’ Verhindert Starvation.
- **Problem:** **Zu kurze Zeitscheiben** verursachen viele Kontextwechsel (Overhead).

=== "ğŸ” Pseudo-Code"

```python
while queue:
    process = queue.pop(0)
    execute(process, timeslice)  # LÃ¤uft fÃ¼r begrenzte Zeit
    if process.remaining_time > 0:
        queue.append(process)  # Wieder in die Warteschlange
```


---

### ğŸ”€ **Multi-Level Feedback Queue (MLFQ)**

**Strategie:**

- **Mehrere Warteschlangen** mit **verschiedenen PrioritÃ¤ten**.
- **Prozesse starten in hoher PrioritÃ¤t** â†’ Falls sie lange laufen, wandern sie in niedrigere PrioritÃ¤ten.
- **Optimiert fÃ¼r Interaktive Prozesse**.

![[mlfq.svg]]