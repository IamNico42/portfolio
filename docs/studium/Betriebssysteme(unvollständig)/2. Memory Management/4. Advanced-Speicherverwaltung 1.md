---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - Betriebssysteme
tags:
  - Course/
---
# **Advanced Speicherverwaltung**

---
## **EinfÃ¼hrung in Paging**

### ðŸŽ¯ **Paging lÃ¶st das Segmentierungsproblem!**

- Speicher wird in **gleich groÃŸe Seiten** (z. B. **4 KB**) unterteilt.
- **Jede virtuelle Seite (Page) wird auf eine physische Seite (Frame) gemappt.**
- Kein Problem mit **externer Fragmentierung** â†’ **kleinere Einheiten** helfen!

### ðŸ” **Wie funktioniert Paging?**

1. Die virtuelle Adresse besteht aus:
    - **Page Number (Seitenindex)** â†’ Welche Seite?
    - **Offset** â†’ Welcher Teil der Seite?
2. **Ãœbersetzung durch Page Table**:
    - `Virtuelle Adresse â†’ Physische Adresse (Page Table Lookup).`
    - Falls Seite nicht im Speicher ist â†’ **Page Fault â†’ Swapping.**

![[Paging.svg]]
### ðŸ–¥ **Beispiel: AdressÃ¼bersetzung in Paging**

**Gegeben:**

- **Virtuelle Adresse** = `0x09F3`
- **SeitengrÃ¶ÃŸe** = `0x400` (1024 Bytes)

**Berechnung:**

1. **Page Number** = `0x09F3 Ã· 0x400` = `2`
2. **Offset innerhalb der Seite** = `0x09F3 % 0x400` = `0x3F3`
3. **SeitenÃ¼bersetzung:**
    - Page Table sagt: `Virtuelle Seite 2 â†’ Physische Seite 5`
    - **Physische Adresse = 5 * 1024 + 0x3F3 = 0x14F3.** âœ…

âœ… **Vorteile von Paging:**

- Kein **externes** Fragmentierungsproblem.
- Erlaubt **Speicherverteilung** auf nicht zusammenhÃ¤ngende Frames.

ðŸš¨ **Problem:** **GroÃŸe Page Tables â†’ Hoher Speicherverbrauch!**  
âž¡ **LÃ¶sung:** **TLBs & Mehrstufige Page Tables (Kapitel 19-20).**

## **Paging - Schnellere Ãœbersetzungen mit TLBs**

### ðŸ”¥ **Warum sind Page Tables langsam?**

- **Jeder Speicherzugriff benÃ¶tigt 2 Speicheroperationen**:
    1. Suche in der **Page Table**.
    2. Zugriff auf den eigentlichen Speicher.

âœ… **LÃ¶sung: Translation Lookaside Buffer (TLB)**

- Ein **Cache fÃ¼r Page Table EintrÃ¤ge**.
- Speichert die zuletzt verwendeten **Ãœbersetzungen**.
- Falls **TLB-Hit**: **Direkte AdressÃ¼bersetzung (ohne Page Table Zugriff).**
- Falls **TLB-Miss**: **Normaler Zugriff auf Page Table.**


```c
// Translation Lookaside Buffer (TLB) Lookup Algorithmus
VPN = (VirtualAddress & VPN_MASK) >> SHIFT

(Success, TlbEntry) = TLB_Lookup(VPN)

if (Success == True)  // TLB Hit
{
    if (CanAccess(TlbEntry.ProtectBits) == True)
    {
        Offset = VirtualAddress & OFFSET_MASK
        PhysAddr = (TlbEntry.PFN << SHIFT) | Offset
        Register = AccessMemory(PhysAddr)
    }
    else
    {
        RaiseException(PROTECTION_FAULT)  // Zugriffsverletzung
    }
}
else  // TLB Miss
{
    RaiseException(TLB_MISS)  // Seitenfehler oder TLB-Eintrag nicht gefunden
}
```

### ðŸ“Š **TLB-Hit/Miss Performance Beispiel**

- Ohne TLB: **200 ns pro Speicherzugriff.**
- Mit TLB (95% Hit-Rate):  
    `0.95 Ã— 100 ns + 0.05 Ã— 200 ns = 105 ns (fast doppelt so schnell).`

âœ… **Vorteil:** **Reduziert den Overhead von Paging erheblich.**

---

## **Mehrstufige Page Tables**

ðŸš€ **Problem:** Einfache Page Tables sind zu groÃŸ!  
Ein 64-Bit System mit **4 KB Seiten** brÃ¤uchte **gigantische Page Tables**.

âœ… **LÃ¶sung: Mehrstufige Page Tables**

- **Hierarchische Struktur**:
    - Erste Stufe zeigt auf **zweite Stufe**, zweite auf **dritte** usw.
    - Nur **benÃ¶tigte Teile der Page Table** werden im Speicher gehalten.

**Beispiel:** **3-stufige Page Table fÃ¼r 64-Bit Speicherverwaltung**

1. **Level 1 Table** â†’ **Level 2 Table** â†’ **Level 3 Table** â†’ **Frame.**
2. **Erspart Speicherplatz**, weil **nur genutzte Tabellen geladen werden.**

âœ… **Vorteil:** **Verbraucht deutlich weniger Speicher fÃ¼r Page Tables.**

---
## **Swapping - Speicher auf Festplatte auslagern**

### ðŸŽ¯ **Was ist Swapping?**

- Falls der **physische RAM voll ist**, werden **Speicherbereiche auf die Festplatte ausgelagert**.

### ðŸ”¥ **Wann wird Swapping genutzt?**

- Wenn ein neuer Prozess **Speicher benÃ¶tigt**, aber der RAM voll ist.
- Das OS **wÃ¤hlt eine nicht benutzte Seite** und speichert sie auf der Festplatte.

ðŸš¨ **Problem:** Swapping auf HDDs ist **extrem langsam** (Millisekunden!).  
âž¡ **Moderne Betriebssysteme nutzen SSDs** oder versuchen Swapping zu vermeiden.

âœ… **LÃ¶sung: Page Replacement Policies**

- **FIFO**: Ã„lteste Seite rauswerfen.
- **LRU (Least Recently Used)**: **Am lÃ¤ngsten nicht genutzte Seite** rauswerfen.
- **Clock Algorithmus**: Verbessert LRU, indem er Seiten prÃ¼ft, ob sie noch genutzt werden.

---

##  **Swapping-Strategien & Page Replacement**

### ðŸ” **Problem: Wann & wie wird ausgelagert?**

- **Zu viel Swapping** fÃ¼hrt zu **Thrashing** (System ist nur noch mit Swapping beschÃ¤ftigt).

âœ… **LÃ¶sungen:**

- **Page Replacement Algorithmen:**
    1. **FIFO:** Ã„lteste Seite rauswerfen.
    2. **LRU:** Seite, die **am lÃ¤ngsten nicht benutzt** wurde.
    3. **Clock Algorithmus:** Effizientere Version von LRU.

âœ… **Moderne Betriebssysteme:**

- Nutzen **hybride Algorithmen** und Machine Learning, um das **beste Swapping-Verhalten zu finden**.

---

# **ðŸš€ Fazit**

Paging & Swapping sind **essentiell fÃ¼r moderne Betriebssysteme**.

- **Paging** lÃ¶st Fragmentierungsprobleme.
- **TLBs** machen Paging **schneller**.
- **Swapping** ermÃ¶glicht **mehr Prozesse, kostet aber Leistung.**