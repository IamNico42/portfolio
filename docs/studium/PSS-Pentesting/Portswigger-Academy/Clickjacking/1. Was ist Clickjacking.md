---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - PSS-Portswigger-Academy
tags:
  - Course/
---
## Was ist Clickjacking
Clickjacking ist ein UI-basierter Angriff, bei dem ein Nutzer dazu gebracht wird, auf interaktive Inhalte einer versteckten Website zu klicken, während er glaubt, auf sichtbare Inhalte einer Köder-Seite zu klicken.
Technisch gesehen wird dabei eine unsichtbare, aber klickbare Seite in einem iframe in die Köderseite eingebettet. Dieses iframe liegt über den erwarteten Inhalten der Seite.
Der Angriff unterscheidet sich von CSRF, weil beim Clickjacking der Nutzer aktiv klickt.

**Warum CSRF-Tokens nicht helfen**
CSRF-Schutz arbeitet oft mit CSRF-Tokens. Bei Clickjacking ist die Zielsitzung aber echt - Die Inhalte werden von der legitimen Webseite geladen und Anfragen laufen on-domain

**Wie baut man einen basic Clickjacking Angriff**
Clickjacking bneutzt CSS um mehere Layer zu erstellen und manipulieren.

```css
<head>
	<style>
			#target_website { 
				position:relative;
				width:128px;
				height:128px;
				opacity:0.00001;
				z-index:2; 
				} 
				#decoy_website { 
				position:absolute; 
				width:300px; 
				height:400px; 
				z-index:1; 
				} 
	</style> 
</head> ... 
<body> 
	<div id="decoy_website"> 
	...decoy web content here... 
	</div> 
	<iframe id="target_website" src="https://vulnerable-website.com"> 
	</iframe> 
</body>
```

## Lab: Basic clickjacking with CSRF token protection

Ziel: Wir sollen einen User dazu bringen seinen Account zu deleten - Wir bauen also eine Baitseite und binden die Target-Seite in einen Iframe wie folgt - Wichtig ist nur, dass der Click Me button mit CSS richtig positioniert wird.

![[Clickjacking_1.png]]

Das sieht dann wie folgt aus ->. User hat nur ein Click Me drübergelegt bekommen, aber die Session ist trotzdem valide zur Target-Seite weil es in unserem iframe eingebettet ist.
![[Clickjacking_2.png]]

## Clickbandit
In der Praxis, obwohl es zwar geht, ist es sehr mühsam ein Clickjacking manuell zu erstellen - Deshalb kommt der Clickbandit ins Spiel. Damit kann man im Browser die gewünschten Aktionen auf der einbettbaren Seite ausführen - anschließend erzeugt Clickbandit eine HTML-Datei mit einem passenden Clickajcking-Overlay. So lässt sich in Sekunden ein interaktives PoC generieren.

## Clickjacking with prefilled form input

Einige Websites, die das Ausfüllen und Absenden von Formularen erfordern, erlauben das **Vorbefüllen** (Prepopulation) von Formfeldern über **GET-Parameter** vor dem Absenden. Andere Websites verlangen möglicherweise Texteingaben, bevor das Formular abgeschickt werden kann. 

Da GET-Werte Teil der **URL** sind, kann die Ziel-URL so verändert werden, dass sie vom Angreifer gewählte Werte enthält. Anschließend wird - wie im grundlegenden Clickjacking-Beispiel - ein **transparenter „Absenden“-Button** über der Köder-Seite platziert. So kann das Opfer das Formular mit den vom Angreifer vorgegebenen Daten unbemerkt absenden.

## Lab: Clickjacking with form input data prefilled from a URL parameter

1. Burp Suit Clickbandit
2. E-Mail Feld mit URL Query ausfüllen 
	- `<iframe src="http://victim.com/my-account?email=attacker%40evil.com" ...>`
3. Copy-Paste Clickbandit Script in Browser Console
4. `start` und Elemente anklicken die wir klicken wollen
5. `finish` um recording von zu klickenden Elementen abzuschließen
6. `save` -> bekommen html file
7. Copy-Paste Inhalt von File in Body teil von Exploit-Server

> [!note] Wichtig ist 
> Dass die URL schon bevor wir auf start drücken prepared wird und dann erst mit dem recording beginnen, damit auch der richtige Link im Script landet.!!


## Frame Busting Scripts

Clientseitige JavaScript-Snippets, die verhindern sollen, dass deine Seite unsichtbar in einem `<iframe>` eingebettet und „durchgeklickt“ wird (Clickjacking). Typische Checks:

- Prüfen: „Bin ich das **Top-Fenster**?“ – sonst rausnavigieren (`top.location = self.location`).
- Alle Frames **sichtbar** machen / Klicks auf **unsichtbare** Elemente blocken.
- Verdächtige Zustände **melden** (Banner/Prompt).

**Warum bringt das oft aber nichts?**
- JS kann aus sein oder vom Browser blockiert werden.
- Frame Buster verhalten sich je nach Browser unterschiedlich
- Same-Origin-Schutz
- iframe sandbox -> Angreifer betten iframe anders sein

**Best-Practice**
Die **richtige** Verteidigung ist, Framing **serverseitig** zu verbieten/zu steuern – nicht per JS:
1. **CSP `frame-ancestors` (modern & flexibel)**
    - Komplett verbieten:
        `Content-Security-Policy: frame-ancestors 'none';`
    - Nur gleiche Origin:
        `Content-Security-Policy: frame-ancestors 'self';`
    - Partner-Whitelist:
        `Content-Security-Policy: frame-ancestors 'self' https://partner.example;`
2. **X-Frame-Options (Legacy, ergänzend)**
    - `X-Frame-Options: DENY` oder `SAMEORIGIN`

Nginx-Schnipsel:
```nginx
add_header Content-Security-Policy "frame-ancestors 'self';" always;
add_header X-Frame-Options "SAMEORIGIN" always;
```


## Lab: Clickjacking with a frame buster script

1. Schritte genau wie oben nur, dass wir Sandbox aktivieren und `allow-forms` hinzufügen müssen damit die Seite framebar wird -> sonst würde das Script anzeigen, dass die Seite nicht framebar ist. 
2![[Clickjacking_2_1.png]]


## Kombiniere Clickjacking mit DOM XSS attack
Voraussetzung: Es gibt eine DOM-XSS Schwachstelle.
Verwendung: XSS-Payload direkt in die URL der eingbetteten Seite packen(im src des iframes)

Das Opfer drückt dann auf einen überlagerten Button/link und triggert damit die DOM-XSS im eingebetteten Kontext
- Clickjacking sorgt dafür, dass das Opfer „zielgenau“ klickt (UI-Redressing).
- DOM-XSS wird durch bestimmte **URL-Teile** (Query/Hash) clientseitig ausgewertet.
- Kombiniert: Der Klick löst die Aktion aus, **inklusive** des XSS-Payloads in der URL.

## Lab: Exploiting clickjacking vulnerability to trigger DOM-based XSS

**Lab kaputt - geht nicht**
Aber theoretisch:
1. DOM XSS Schwachstelle finden
2. DOM-XSS Payload und weitere prefilled Inhalte mit Query-Link erstellen
3. Danach mit Clickbandit ein setup erstellen



## Multistep clickjacking

Beim **Multi-Step-Clickjacking** braucht der Angreifer mehrere aufeinanderfolgende Nutzeraktionen (z. B. zuerst „In den Warenkorb“, dann „Zur Kasse“, dann „Bestellen“). Das lässt sich durch mehrere überlagerte **Divs/iframes** umsetzen. Man täuscht z. B. „Weiter“, „Noch mal Weiter“, „Jetzt gewinnen!“ vor - und legst jedes Mal ein anderes (fast unsichtbares) iframe deckungsgleich über den decoy-Button.


## Lab: Multistep clickjacking

**Lab kaputt - geht nicht**
Aber theoretisch:
```
<style>
	iframe {
		position:relative;
		width:500px;
		height: 700px;
		opacity: 0.1;
		z-index: 2;
	}
   .firstClick, .secondClick {
		position:absolute;
		top:500px;
		left:50px;
		z-index: 1;
	}
   .secondClick {
		top:290px;
		left:225px;
	}
</style>
<div class="firstClick">Test me first</div>
<div class="secondClick">Test me next</div>
<iframe src="https://0ae500f704a9c699804ca41200ac0017.web-security-academy.net/my-account"></iframe>
```