---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - PSS-Portswigger-Academy
tags:
  - Course/
---

## **Absicherung einer GraphQL-API (Allgemein)**

### 1. **Introspection deaktivieren (wenn möglich)**

- Wenn deine API **nicht öffentlich** ist → **Introspection ausschalten**.  
    So kann niemand mehr das komplette Schema auslesen oder versteckte Felder entdecken
- Wenn sie **öffentlich** ist → Introspection aktiv lassen, **aber prüfen**, dass das Schema keine sensiblen Felder enthält (z. B. `passwordHash`, `email`, `token`, `userId`).
    
### 2. **Suggestions deaktivieren**

- „Did you mean …?“-Vorschläge (Suggestions) dürfen **nicht aktiv** sein, weil sie Angreifern verraten, welche Felder im Schema existieren.
- Apollo erlaubt kein direktes Abschalten → es gibt aber Workarounds (z. B. über `formatError()` in der Server-Konfiguration, siehe GitHub-Thread).
    
### 3. **Keine privaten Felder veröffentlichen**

- Das Schema darf **keine sensiblen Userdaten** enthalten (z. B. E-Mail, interne IDs, Rollen).
- Überprüfe, was der Resolver wirklich zurückgibt – auch bei Introspection oder public Queries.
    

---

## **Schutz vor Brute-Force- und DoS-Angriffen**

Angreifer können z. B. mit **Aliases** viele Anfragen in **einem Request** stellen oder durch **verschachtelte Queries** den Server überlasten.  
→ Gegenmaßnahmen:
###  1. **Query-Tiefe begrenzen**

- Setze ein Limit, wie tief Queries verschachtelt werden dürfen (z. B. max. 5 Ebenen).
- Damit verhinderst du zu komplexe / rekursive Anfragen, die den Server lahmlegen können.
### 2. **Operation-Limits konfigurieren**

- Beschränke:
    - **Anzahl der Felder**
    - **Anzahl der Aliases**
    - **Anzahl der Root-Felder**  
        pro Anfrage.  
        → So kann niemand 1000 Operationen in einem Request verstecken.
        
### 3. **Maximale Query-Größe (Bytes) festlegen**

- Jede Query darf nur bis zu einer bestimmten Größe (z. B. 10 KB) haben.  
    → Schutz gegen riesige Requests.
    
### 4. **Kostenanalyse (Cost Analysis) aktivieren**

- Jeder Field-Resolver bekommt einen „Kostenfaktor“.
- Wenn eine Query zu teuer wird (z. B. zu viele Felder oder tiefe Strukturen), wird sie **abgewiesen**.
- In Apollo kannst du das mit Libraries wie `graphql-cost-analysis` oder `graphql-query-complexity` umsetzen.
    

---

## **CSRF-Schutz für GraphQL**

1. **Nur POST mit JSON akzeptieren**  
    → Keine GET- oder Form-Submits.
2. **Content-Type prüfen**  
    → Anfrage muss `Content-Type: application/json` haben.
3. **CSRF-Token verwenden**  
    → Klassisches Anti-CSRF-Verfahren (Token, das bei jedem Request mitgeschickt und überprüft wird).