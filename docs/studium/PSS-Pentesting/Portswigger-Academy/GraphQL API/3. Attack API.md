---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - PSS-Portswigger-Academy
tags:
  - Course/
---
## Suggestions

Wenn Introspection deaktiviert dann könnte man trotzdem mit Suggestions informationen ermitteln. GraphQL-Server schlägt dann vor was man meinen könnte.
### Wie ein Angreifer das nutzt - Idee in 3 Schritten

1. Schicke eine **absichtlich falsche** Query (z. B. Tippfehler im Feldnamen).
2. Lies die Fehlerantwort: enthält sie Vorschläge, bekommst du valide Feld/Typ-Namen.
3. Wiederhole / automate → baue so (teilweise) das Schema nach.

## Bypassing GraphQL introspection defenses

Wenn man keine introspection queries laufen lassen kann könnte man versuchen einfach 
- nur ein special character hinter `__schema` anfügen.
- Oder POST in GET ändern
- Oder POST Request mit Content-Type `x-www-form-urlencoded`
	`GET /graphql?query=query%7B__schema%0A%7BqueryType%7Bname%7D%7D%7D`


## Lab: Finding a hidden GraphQL endpoint
1. API Endpunkte finde durch manuelles testen möglich![[graphql_api_1.PNG]]
2. Schauen ob der Endpunkte queries nimmt![[graphql_api_2.PNG]]
3. Jetzt können wir mit unserer InQL Extension einen introspection query setzen![[graphql_api_3.PNG|675]]
4. Wir stellen fest der Server hat einen Filter dagegen![[graphql_api_4.PNG]]
5. Filter umgehbar mit einfachen`%0a(New line)`   ![[graphql_api_5.PNG]]
6. Dann geschaut was es so gibt und folgendes gefunden. ![[graphql_api_6.PNG]]
7. Wir schicken das an unsere `Target->Site map` um zu schauen welche API queries es gibt.
8. Dann beide Requests an den Repeater und Variable-Feld decoded, bearbeitet und wieder encoded![[graphql_api_7.PNG]]
9. Mit dem einen querie konnten wir user auslesen und deren ID(Variable in Smart Decoder um die ID manuell zu ändern)![[graphql_api_8.PNG]]
10. Mit der anderen Querie konnten wir dann User löschen anhand ihrer ID![[graphql_api_9.PNG]]


## Rate Limit umgehen

- GraphQL ist ein Post-Request, der viele Fragen in einem Request beantworten kann.
- **Alias** = du gibst einer Frage in derselben Anfrage einen neuen Namen, damit du dieselbe Frage mehrfach stellen kannst.
- Viele Server zählen nur **Anfragen pro Minute** (z. B. 100 Requests/min). Wenn du aber in **einem** Request 50 Fragen packst, zählt das immer noch als **1** Request — ergo: du kannst _mehr_ ausprobieren, ohne das Rate-Limit auszulösen.

z. B.
```sql
query {
  a: isValidDiscount(code: "CODE1") { valid }
  b: isValidDiscount(code: "CODE2") { valid }
  c: isValidDiscount(code: "CODE3") { valid }
}
```
Server zählt 1 HTTP-Request, macht aber 3 Prüfungen. Damit kann man z.B. viele Rabattcodes auf einmal ausprobieren.


## Lab: Bypassing GraphQL brute force protections

![[graphql_api_ratelimit_1.PNG]]
![[graphql_api_ratelimit_2.PNG]]
![[graphql_api_ratelimit_3.PNG]]
![[graphql_api_ratelimit_4.PNG]]
![[graphql_api_ratelimit_5.PNG]]


## GrapgQL CSRF

GraphQL kann im Zusammenhang mit CSRF genutzt werden.  Wir können gewisse Payloads bauen und die dann über CSRF bei anderen Usern einschläusen.

**Diese Schwachstelle entsteht wenn** der **Content-Type** nicht validiert wird. In diesem Fall können wir `x-www-form-urlencoded` nutzen