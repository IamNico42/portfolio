---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - PSS-Portswigger-Academy
tags:
  - Course/
---
## SQL Injection In Different Contexts (JSON,XML)

In den bisherigen Methoden haben wir uns ausschließlich über direkte String Injections auseinandergesetzt. 
Apps können aber auch z. B. diversen JSON oder XML formatierte Daten in einen SQL Query umwandeln. Dort wiederum werden oft Key-Words durch WAFS oder andere defense Mechanismen geblock, aber auch da gibt es die Möglichkeit einzelne Character zu encoden um aus diesem Filter auszubrechen.
z. B.

```xml
<stockCheck> 
	<productId>123</productId> 
	<storeId>999 &#x53;ELECT * FROM information_schema.tables</storeId> 
</stockCheck>
```


## Lab: SQL injection with filter bypass via XML encoding

1. Erstmal wieder auf der Seite suchen wo potentielle Schachstellen liegen können
2. Haben eine potentielle Schachstelle gefunden![[sqli_xml_bypass1.PNG]]
3.  Dort sehen wir es wird durch ein WAF geschützt. Also versuchen wir es zu encoden![[sqli_xml_bypass2.PNG]]
4. Wir sehen, encoding mit **HACKVERTOR** **Extension** schlägt an und versuchen zusätzlich Parameter wie UNION SELECT einzubauen. [[2. SQL Injection UNION Attacks]]
5. Nach bisschen rumprobieren sehen wir, dass folgendes anschlägt. (Bei falscher Konstellation bekommen wir nur 0 Units als Response) ![[sqli_xml_bypass3.PNG]]
6. Dann schauen wir welcher Datentyp und welche Version wir haben. Wir stellen fest bei Version() und einem String haben wir Treffer
```sql
PostgreSQL 12.22 (Ubuntu 12.22-0ubuntu0.20.04.4) on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0, 64-bit
```
   7. Jetzt schauen wir welche Tabellen es gibt. (Befehle lassen sich aus dem SQL Injection Cheat-Sheet von Portswigger entnehmen)![[sqli_xml_bypass4.PNG]]
   8. Das gleiche dann mit column_name ![[sqli_xml_bypass5.PNG]]
   9. Und jetzt können wir username und passwörter auslesen  ![[sqli_xml_bypass6.PNG]]