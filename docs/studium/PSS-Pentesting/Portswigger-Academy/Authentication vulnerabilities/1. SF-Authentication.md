---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - PSS-Portswigger-Academy
tags:
  - Course/
---
## Allgemein

Authentication ist ein Prozess der User bzw. Clients identifiziert und ggf. unterschiedliche Rechte auf Webseiten verteilt, weil Webseiten in erster Linie erstmal Ã¶ffentlich fÃ¼r das ganze Internet ist.
Deswegen sind robuste Authentication-Mechanismen essenziell fÃ¼r Web-Security.

Es gibt 3 verschiedene Haupttypen
- Etwas was man **weiÃŸ** z. B: Passwort
- Etwas was man **hat** z. B: SchlÃ¼ssel
- Etwas was man **ist** z. B: FingerabdrÃ¼cke, Gesichtserkennung oder Verhaltensweisen

**Authentication**: Prozess um von jemandem die IdentitÃ¤t zu bestÃ¤tigen
**Authorization**: Welche Art von Rechte hat der User


### Wie entstehen vulnerabilities beim authentifizieren

- Zu Schwache Mechanismen und nicht gegen Brute-Force gesichert
- Schlechte Implementierung sodass der Hacker das einfach bypassen kann (Broken Authentication)


## Brute-Force

Verschiedene Passwort/Username Kombinationen durch Trial und Error mit einem Algorithmus durchlaufen lassen.
###### gezielteres Brute-Force
Bei einem gezielterem Brute-Force werden gewisse Passwortlisten genommen oder wahrscheinlichere Kombinationen verwendet.

AuÃŸerdem muss man auf diverse Dinge achten die ggf. Auskunft Ã¼ber zB: korrekte Usernamen geben durch:
- **Status Code**: WÃ¤hrend einer Brute-Force attacke ist es wichtig immer die selbe Fehlermeldung zu liefern also ob Username nun richtig oder falsch ist sonst kann ein unterschiedlicher Status-Code Auskunft darÃ¼ber liefern ob der Username in der Datenbank auftaucht oder nicht.
- **Error messages**: Manchmal kÃ¶nnten auch Error Messages unterschiedliche Ausgaben liefern zB: "Username ist falsch" oder "Username und Passwort sind falsch" oder "Passwort ist falsch"
- **Response Time**: Je nachdem ob ein Username korrekt ist braucht das System lÃ¤nger weil es nach dem zugehÃ¶rigen Passwort sucht was eine lÃ¤ngere response-time bedeuten kÃ¶nnte wodurch sich auch erahnen lÃ¤sst ob ein Username richtig oder falsch ist

---
## ðŸ–¥ï¸ðŸ§ªLab: Username enumeration via different responses

1. Suche nach POST /login request.![[username_enumeration_burp1.png]]
2. An Intruder senden, Passwortliste einfÃ¼gen und start Attack![[username_enumeration_burp2.png]]
3. Length unterschiedlich -> Username vermutlich korrekt![[username_enumeration_burp3.png]]
4. Dann das gleiche mit Passwort und dem gefundenen Usernamen wiederholen. -> Statuscode 302![[username_enumeration_burp4.png]]

---
##  ðŸ–¥ï¸ðŸ§ªLab: Username enumeration via subtly different responses

**Ziel:**  
Analyse der Login-Funktion, um Unterschiede bei falschen und korrekten Eingaben zu erkennen und anschlieÃŸend einen erfolgreichen Brute-Force Angriff durchzufÃ¼hren.

**Vorgehen:**

1. **Erste Tests im Intruder:**
    - Alle Responses hatten Status Code `200`.
    - Die **Response Length** war zwar unterschiedlich, der Unterschied entstand jedoch nur durch ein eingebundenes Analytics-Script â†’ **kein valider Indikator**.
        
2. **Vergleich der Fehlermeldungen:**
    - Verschiedene Keywords getestet (Grep Match).
    - Mit komplett falschen Usernamen (`asd7127371231b2n178z`) Response im Repeater Ã¼berprÃ¼ft.
    - Unterschied entdeckt:
        - **UngÃ¼ltiger Username** â†’ Fehlermeldung: _â€œInvalid username and password.â€_
        - **GÃ¼ltiger Username, falsches Passwort** â†’ Fehlermeldung fast gleich, aber **ohne Punkt am Ende**.
    - Damit konnte ein **valider Benutzername** identifiziert werden.
        
3. **Brute Force Passwort-Test:**
    - Den ermittelten gÃ¼ltigen Benutzernamen mit einer Passwortliste im Intruder getestet.
    - Nach Auswertung der Responses â†’ **Login erfolgreich** â†’ Zugang erhalten.
        

**Ergebnis:**  
Die Login-Funktion ist anfÃ¤llig fÃ¼r **Username Enumeration** (durch subtile Unterschiede in den Fehlermeldungen) und erlaubt anschlieÃŸend einen erfolgreichen **Brute-Force Angriff** auf das Passwort.

---
## ðŸ–¥ï¸ðŸ§ª LAB: Authentication â€“ Username Enumeration & IP-Blocker Bypass

**Ziel:**  
Analyse der Login-Funktion hinsichtlich Brute-Force-Absicherung, Username Enumeration und mÃ¶glichen Bypass-Mechanismen.

1. Erste Beobachtungen
	- Bei einem **korrekten Benutzernamen** und einem absichtlich **langen Passwort** dauert die Antwort des Servers **signifikant lÃ¤nger**.
	- Bei einem **falschen Benutzernamen** erfolgt die Antwort dagegen **sehr schnell**.  
	    â†’ Dadurch lÃ¤sst sich eine **Username Enumeration Ã¼ber Response Time** durchfÃ¼hren.
    
2. IP-Blocker
	- Nach ca. **3 fehlgeschlagenen Login-Versuchen** wurde die Client-IP blockiert.
	- Durch Tests festgestellt: Ein einfacher **`X-Forwarded-For`-Header** reicht aus, um die Sperre zu umgehen.
	- Das System vertraut offenbar den Ã¼bergebenen Headern und wertet diese fÃ¼r die IP-Erkennung aus.
    
3. Vorgehen mit Burp Intruder
	1. **Payload Setup:**
	    - **Benutzername:** Liste mit potentiellen Usernamen.
	    - **Passwort:** Konstant ein langes Passwort, um Response Time-Unterschiede deutlicher zu machen.
	    - **X-Forwarded-For:** Als zweiter Payload-Parameter â†’ IP-Adresse dynamisch hochzÃ¤hlen (z. B. `1.1.1.Â§1Â§`).
	        
	2. **Angriff:**
	    - Intruder-Attacke gestartet mit 2 Positionen:
	        - Benutzername â†’ arbeitet die Liste durch.
	        - X-Forwarded-For â†’ erhÃ¶ht bei jedem Versuch die letzte IP-Ziffer.
	            
	    - Ergebnis:
	        - Der **korrekte Benutzername** konnte eindeutig identifiziert werden, da die Response Time deutlich hÃ¶her war als bei allen anderen Requests.
            
4. Passwort Brute Force:
    - Danach denselben Ansatz mit dem bekannten, validen Benutzernamen.
    - Passwortliste abgearbeitet, X-Forwarded-For weiter rotiert, um Sperre zu umgehen.
    - Ergebnis: **Login erfolgreich**.
        
5. Ergebnis
	- Die Anwendung ist anfÃ¤llig fÃ¼r:
	    1. **Username Enumeration via Response Time**.
	    2. **Brute Force trotz IP-Blocker**, da `X-Forwarded-For` manipuliert werden kann.



**Ziel:**  
Analyse der Login-Schutzmechanismen, insbesondere der IP-Blockierung bei fehlerhaften Versuchen und deren mÃ¶gliche Umgehung.

---
## Lab: Broken brute-force protection, IP block
1. Erste Beobachtungen
	- Die Login-Funktion blockiert eine IP-Adresse nach **3 fehlgeschlagenen Versuchen**.
	- Anders als in der Variante mit `X-Forwarded-For` konnten wir diesmal feststellen:  
	    Ein **erfolgreicher Login** (z. B. mit einem bekannten gÃ¼ltigen Account) **setzt die IP-Blockliste zurÃ¼ck**.
	- Damit ist es mÃ¶glich, den Brute-Force-Schutz durch periodische â€žReset-Loginsâ€œ auszuhebeln.
	    

 2. Vorgehen
	1. **Analyse mit Burp Repeater:**
	    - Mehrfach falsche PasswÃ¶rter gesendet â†’ Blockierung nach 3 Versuchen bestÃ¤tigt.
	    - Danach mit gÃ¼ltigem Account (â€žwiener:peterâ€œ) eingeloggt â†’ Blockierung sofort aufgehoben.
	        
	2. **Strategie fÃ¼r Brute Force:**
	    - Wir haben eine Passwortliste fÃ¼r den Zieluser â€žcarlosâ€œ vorbereitet.
	    - In regelmÃ¤ÃŸigen AbstÃ¤nden nach jeweils 3 Versuchen wurde ein zusÃ¤tzlicher Login mit â€žwiener:peterâ€œ eingestreut, um die Blockierung zurÃ¼ckzusetzen.
	    - Dadurch konnten die Brute-Force-Versuche ohne Unterbrechung fortgesetzt werden.
	        
	3. **Umsetzung:**
	    - Zwei Payload-Sets im Intruder:
	        - **Benutzername:** HauptsÃ¤chlich â€žcarlosâ€œ, alle 3 Versuche ergÃ¤nzt durch â€žwienerâ€œ.
	        - **Passwort:** Aus Passwortliste, alle 3 Versuche ergÃ¤nzt durch â€žpeterâ€œ.
	    - Ergebnis: Der IP-Blocker griff nicht mehr, da jede Blockade durch den gÃ¼ltigen Login sofort zurÃ¼ckgesetzt wurde.
	    - Der korrekte Benutzername und anschlieÃŸend das Passwort konnten so gefunden werden.
        
3. Ergebnis
	- Die Anwendung ist anfÃ¤llig fÃ¼r **Brute Force trotz IP-Blocker**, weil ein erfolgreicher Login die Blockliste sofort lÃ¶scht.
	- Der Schutzmechanismus ist dadurch wirkungslos, sobald Angreifer Zugang zu irgendeinem gÃ¼ltigen Account haben.


## Account Locking 

**Grundidee:**  
Webseiten sperren Accounts nach einer bestimmten Anzahl fehlgeschlagener Login-Versuche, um Brute-Force-Angriffe zu erschweren.

**Vorteile**
- SchÃ¼tzt bedingt vor Brute-Force-Angriffen auf **ein bestimmtes Konto**, da dieses nach wenigen Fehlversuchen gesperrt wird.

**SchwÃ¤chen / UmgehungsmÃ¶glichkeiten**
1. **Username Enumeration**
    - Wenn der Server bei gesperrten Accounts andere Fehlermeldungen zurÃ¼ckgibt, kÃ¶nnen Angreifer dadurch gÃ¼ltige Usernamen erkennen.
    
2. **Brute Force gegen viele Accounts**
    - Schutz greift nur bei Angriffen auf ein einzelnes Konto.
    - Angreifer kÃ¶nnen mehrere Accounts parallel angreifen, solange sie das Limit pro Account nicht Ã¼berschreiten.
    - Beispiel:
        - Max. 3 Versuche erlaubt â†’ Angreifer probiert pro User 3 Standard-PasswÃ¶rter.
        - Es reicht, wenn ein User tatsÃ¤chlich eines dieser PasswÃ¶rter nutzt â†’ Account kompromittiert.
            
3. **Credential Stuffing**
    - Bei Credential Stuffing werden echte, gestohlene Zugangsdaten (aus Leaks) massenhaft ausprobiert.
    - Da pro Account nur **ein Login-Versuch nÃ¶tig** ist, greift Account Locking hier nicht.
    - Besonders gefÃ¤hrlich, weil viele Nutzer ihre PasswÃ¶rter auf mehreren Webseiten wiederverwenden â†’ Angreifer kÃ¶nnen so gleich mehrere Accounts Ã¼bernehmen.


## User Rate Limiting

**Ansatz:**  
Eine weitere MÃ¶glichkeit, Brute-Force-Angriffe zu verhindern, ist **Rate Limiting pro Benutzer/IP**.
- Wenn zu viele Login-Versuche in kurzer Zeit von derselben IP ausgehen, wird diese IP blockiert.
- Die Entsperrung kann erfolgen:
    - automatisch nach einer bestimmten Zeit,
    - manuell durch einen Administrator,
    - manuell durch den Benutzer (z. B. per CAPTCHA).
        

**Vorteil gegenÃ¼ber Account Locking:**
- Weniger anfÃ¤llig fÃ¼r Username Enumeration und DoS-Angriffe.
    

**SchwÃ¤chen:**
- Angreifer kÃ¶nnen ihre scheinbare IP manipulieren (z. B. per Proxy oder Header-Manipulation), um die Sperre zu umgehen.
- In manchen FÃ¤llen lÃ¤sst sich die Sperre auch aushebeln, indem mehrere Passwortversuche in einer einzigen HTTP-Anfrage kombiniert werden.


## Schwachstellen bei Multi-Faktor-Authentifizierung (MFA)

Viele Websites nutzen noch reine **Single-Factor Authentifizierung** (Passwort). Immer hÃ¤ufiger wird aber **Zwei-Faktor-Authentifizierung (2FA)** eingesetzt, bei der Nutzer etwas wissen (Passwort) **und** etwas besitzen (z. B. Code vom GerÃ¤t).
### Vorteile von 2FA
- Angreifer kÃ¶nnen evtl. ein Passwort stehlen.
- Gleichzeitig an den **zweiten Faktor** zu kommen, ist deutlich schwerer.
- Darum ist 2FA **grundsÃ¤tzlich sicherer** als reines Passwort-Login.
    
### Probleme & Schwachstellen
1. **Schlechte Implementierung**
    - 2FA ist nur so sicher wie die Umsetzung.
    - Fehler kÃ¶nnen dazu fÃ¼hren, dass man 2FA **umgehen oder ganz Ã¼berspringen** kann.
        
2. **Gleicher Faktor doppelt geprÃ¼ft**
    - E-Mail-basierte 2FA gilt nicht als echte Zwei-Faktor-Authentifizierung.
    - Der Nutzer gibt Passwort ein und erhÃ¤lt Code per Mail â†’ beide hÃ¤ngen vom **Wissen des E-Mail-Passworts** ab.
    - Ergebnis: Es wird **nicht wirklich ein zweiter Faktor** geprÃ¼ft.
        
3. **Token-Methoden**
    - **Sicherer:** Dedizierte GerÃ¤te (RSA-Token, Keypads) oder Apps wie Google Authenticator â†’ Code wird lokal auf dem GerÃ¤t generiert.
    - **Unsicherer:** SMS-Codes â†’ kÃ¶nnen abgefangen werden (z. B. durch Angriffe auf das Mobilfunknetz).
        - Risiko: **SIM-Swapping** â†’ Angreifer Ã¼bernimmt Rufnummer, erhÃ¤lt alle SMS inklusive 2FA-Codes.
            
4. **Bypass-Szenarien**
    - Manche Websites setzen 2FA technisch falsch um:
        - Zuerst Passwort-Eingabe, danach Code-Eingabe auf separater Seite.
        - Nach Passwort-Eingabe gilt der Nutzer bereits als â€žeingeloggtâ€œ.
        - Angreifer kann direkt auf geschÃ¼tzte Seiten zugreifen, ohne jemals den Code einzugeben.
            
## Lab: 2FA simple bypass

Oft wird eine 2FA abgefragt, aber letztlich gar nicht gegengecheckt.
D. h wenn man sich einloggt mit dem Passwort kann es sein, dass ein einfaches droppen vom 2. Login den Zugang ermÃ¶glicht. So wie in der Lab Aufgabe


## Lab: 2FA broken logic

NachtrÃ¤glicher Bericht.

Man muss aufpassen, dass man nicht den 2FA brute-forcen kann.
-> User ausloggen bei zu vielen fehlschlÃ¤gen mit 2FA -> in der praxis aber oft sinnlos weil ein advancter Hacker auch diesen Prozess automatisieren kann mit Burp Makros
