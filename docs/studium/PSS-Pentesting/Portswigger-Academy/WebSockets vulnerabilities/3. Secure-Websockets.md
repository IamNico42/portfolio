---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - PSS-Portswigger-Academy
tags:
  - Course/
---
## ğŸ” Sicherer Einsatz von WebSockets

### 1. **`wss://` verwenden (WebSockets Ã¼ber TLS)**

- **Was ist das?**
    - `ws://` ist unverschlÃ¼sselt (wie HTTP).
    - `wss://` ist verschlÃ¼sselt (wie HTTPS).
        
- **Warum wichtig?**
    - SchÃ¼tzt vor **Man-in-the-Middle-Angriffen** (z. B. AbhÃ¶ren im WLAN oder durch kompromittierte Router).
    - Ohne TLS kÃ¶nnten Angreifer Nachrichten oder sogar den Handshake manipulieren.
        
- **Praxis:**
    - Server mit TLS-Zertifikat betreiben.
    - Client immer nur `wss://`-URLs verwenden.
        

---

### 2. **WebSocket-URL hardcoden â€“ keine Benutzereingaben Ã¼bernehmen**

- **Problem:**
    - Wenn der Client die URL dynamisch z. B. aus Query-Parametern oder Cookies zusammenbaut, kÃ¶nnte ein Angreifer die URL manipulieren.
    - Beispiel:
    
        `var ws = new WebSocket("wss://" + location.search.split("=")[1]);`
        â†’ Angreifer hÃ¤ngt `?url=evil.com` an â†’ Verbindung geht zu seiner Domain.
        
- **Warum wichtig?**
    - Damit verhinderst du, dass Angreifer deinen Client auf fremde, manipulierte WebSockets umleiten.
        
- **Praxis:**
    - URL fest im Code oder in einer sicheren Config-Datei definieren.
    - Keine Benutzereingaben oder unsichere Quellen fÃ¼r die Endpoint-URL zulassen.
        

---

### 3. **Handshake gegen CSRF absichern (Schutz vor Cross-Site WebSocket Hijacking)**

- **Problem:**
    - StandardmÃ¤ÃŸig hÃ¤ngen Browser beim Handshake automatisch die Session-Cookies an.
    - Ohne Schutz kann ein Angreifer Ã¼ber eine eigene Webseite eine Verbindung im Kontext des Opfers aufbauen.
        
- **LÃ¶sung:**
    - Wie bei normalen HTTP-Anfragen â†’ **CSRF-Token** einbauen, die nur die legitime Anwendung kennen kann.
    - `Origin`-Header streng prÃ¼fen â†’ Verbindungen nur von eigenen Domains akzeptieren.
        
- **Praxis:**
    - Beispiel:
        - Client holt sich erst ein **CSRF-Token** per HTTPS.
        - Schickt es zusÃ¤tzlich im Handshake (z. B. als URL-Parameter oder Custom-Header).
        - Server prÃ¼ft: passt Token zu Session? Wenn nein â†’ Verbindung ablehnen.
            

---

### 4. **Alle Daten als untrusted behandeln (beidseitig!)**

- **Problem:**
    - WebSocket-Kommunikation ist **bidirektional**.
    - Server bekommt Daten vom Client â†’ kann Angriffe enthalten (SQL Injection, Command Injection).
    - Client bekommt Daten vom Server â†’ kÃ¶nnte XSS oder Script Injection enthalten.
        
- **Warum wichtig?**
    - WebSockets sind ein Transportweg â€“ alle bekannten Input-basierenden Schwachstellen kÃ¶nnen hier auftreten.
        
- **Praxis:**
    - **Server:**
        - Eingaben validieren, escapen, Parameterized Queries nutzen.
            
    - **Client:**
        - Daten niemals ungefiltert mit `.innerHTML` rendern.
        - Immer escapen oder DOM-sicher einfÃ¼gen (`.textContent`).


### âœ… Zusammenfassung

Um WebSockets sicher zu betreiben:
1. **Immer verschlÃ¼sseln** (`wss://`).
2. **Endpoint-URL festlegen** â€“ keine dynamischen Quellen.
3. **CSRF-Schutz** im Handshake â†’ Token + Origin-PrÃ¼fung.
4. **Datenhygiene** â†’ Eingaben und Ausgaben strikt validieren und escapen.