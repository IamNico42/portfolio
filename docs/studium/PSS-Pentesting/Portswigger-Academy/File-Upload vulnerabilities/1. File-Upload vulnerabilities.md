
## Was ist das?

Wenn User Dateien auf einen Server hochladen dÃ¼rfen, ohne dass diese vorher **valide geprÃ¼ft** werden (Name, Typ, Inhalt, GrÃ¶ÃŸe), entsteht das Risiko, dass selbst ein harmloser Image-Upload zur **kritischen Schwachstelle** wird.

**Gefahren:**
- Upload beliebiger Dateien, inkl. Exploits
- Remote Code Execution (Worst Case)
- Path Traversal + File Upload = extrem gefÃ¤hrlich
- Ãœberschreiben existierender Dateien bei gleichen Namen
    

### Zwei zentrale Faktoren:

1. **Welche Eigenschaften schlecht validiert werden**
    - GrÃ¶ÃŸe, Typ, Inhalte, Encoding
        
2. **Was nach dem Upload mit der Datei passiert**
    - Speicherort, Rechte, AusfÃ¼hrbarkeit
        

**Worst Case:**  
Server erlaubt z. B. Upload von _.php_ -> Datei wird **ausgefÃ¼hrt** -> Webshell = Server-KomplettÃ¼bernahme.

## Wie entstehen solche Schwachstellen?
Auch wenn fast jede Website Upload-Restriktionen hat, scheitert es oft an:
### 1. Fehlerhaften Validierungsmechanismen

- Blacklisting gefÃ¤hrlicher Types -> unvollstÃ¤ndig, leicht zu umgehen
- Parsing-Unterschiede (z. B. `.phP`, `.php.` oder `.php%00.jpg`)
- Manipulierbare Eigenschaften wie `Content-Type`
    
### 2. Inkonsequente Validierung

- Unterschiedliche Hosts/Verzeichnisse prÃ¼fen unterschiedlich
- Einzelne Endpunkte vergessen oder anders konfiguriert
    
### 3. Schwache PrÃ¼fung des Datei-Inhalts

- MIME-Type wird blind vertraut
- Magic Bytes nicht geprÃ¼ft
- Tools kÃ¶nnen Fake-JPEG, Fake-PNG usw. generieren
    

## Wie Webserver mit statischen Dateien umgehen

### **1. Nicht-ausfÃ¼hrbare Dateien**

(z. B. Bilder, CSS, statisches HTML)  
-> Server gibt die Datei **direkt** aus.

### **2. AusfÃ¼hrbare Dateien**

(z. B. PHP, JSP)  
-> Server interpretiert die Datei:
- setzt Variablen anhand des Requests
- fÃ¼hrt Skript aus
- schickt Script-Output zurÃ¼ck
    

### **3. AusfÃ¼hrbare Dateien, die _nicht_ ausgefÃ¼hrt werden dÃ¼rfen**

-> Normalerweise Fehler  
-> Bei Fehlkonfiguration: **Quellcode-Leak!**

Hinweis:  
`Content-Type` zeigt oft, was der Server denkt verschickt zu haben (nicht immer zuverlÃ¤ssig).

## Webshell Deployment (RCE)

Das kritischste Szenario:  
**Server erlaubt Upload + AusfÃ¼hrung von serverseitigem Code.**

### Beispiele

**File lesen:**
`<?php echo file_get_contents('/path/to/target/file'); ?>`

**Beliebige Befehle ausfÃ¼hren:**
`<?php echo system($_GET['command']); ?>`

**Anfrage-Beispiel:**
`GET /example/exploit.php?command=id HTTP/1.1`

Resultat:  
Volle Kontrolle Ã¼ber den Server (lesen/schreiben, pivoting, exfiltration usw.)

## Wie verhindert man das?

### **1. Whitelist statt Blacklist**

Definiere erlaubte File-Types (z. B. JPG, PNG) - alles andere blockieren.

### **2. Dateinamen bereinigen**

- keine Traversal-Sequenzen (`../`)
- keine Sonderzeichen, keine Nullbytes
    

### **3. Dateien umbenennen**

- verhindert Ãœberschreiben
- verhindert Ausnutzen bestimmter Namensmuster
    

### **4. Dateien erst _nach_ kompletter Validierung speichern**

- vorher Sandbox / tmp-Ordner nutzen
    

### **5. Best Practices / Frameworks nutzen**

- nie eigene â€Quick & Dirtyâ€œ-Validierung bauen
    
# ğŸ”§ Erweitere Angriffsszenarien

## ğŸ› ï¸ Ãœberschreiben von Server-Konfigurationen

- Apache liest `.htaccess` in Ordnern  
    -> kann Execution Rules Ã¤ndern -> Upload = RCE mÃ¶glich

Beispiele:

- `.htaccess`
- `.user.ini` (PHP)
- `.config` Files
    

## Nullbytes / Encoding / Parsing Tricks

Klassische Bypasses:

```c
.pHp
.htaccess Ã¼berschreiben
%2Ephp
.php%00.png
%00.jpg
.asp;.jpg
.php.
exploit.p.phphp
```

Mix aus Encodings erzeugt oft **Parsing-Inkonsistenzen**.

## Schwachstellen bei der Dateiinhaltsvalidierung

### Magic Bytes prÃ¼fen

Beispiele:
- JPEG: `FF D8 FF`
- PNG: `89 50 4E 47`
    

Angreifer kÃ¶nnen:
- Magic Bytes faken
- Polyglot-Files bauen (.jpg + .php gleichzeitig)
    

## Moderne Systeme & Sandbox-Validierung

Viele moderne Upload-Systeme arbeiten so:

1. Datei kommt in Sandbox (nicht direkt ins Filesystem)
2. Dateiname wird randomisiert
3. komplette Validierung
4. Wenn OK -> Ãœbernahme ins echte Filesystem
    

**Race Conditions** mÃ¶glich:

- Datei wird ausgefÃ¼hrt, bevor sie gelÃ¶scht wird
- besonders bei URL-Uploads (System muss erst downloaden)
    

## Alternative Angriffe (ohne RCE)

## 1. Client-Side Script Uploads

- HTML, SVG, Markdown -> XSS payloads
- DOCX/XLSX -> XXE / Macro-Abuse
    

## 2. PUT-Uploads

Wenn WebDAV / PUT offen ist:
`PUT /images/exploit.php HTTP/1.1 Host: vulnerable-website.com Content-Type: application/x-httpd-php`
-> Datei wird direkt gespeichert = RCE

# ğŸ›¡ï¸ Zusammenfassung - Wie verhindert man File-Upload Vulnerabilities

- **Whitelist erlaubter Endungen**
- **Dateinamen bereinigen & umbenennen**
- **Content-Type und Magic Bytes prÃ¼fen**
- **Sandbox-Validierung nutzen**
- **Frameworks statt eigene Validatoren**
- **AusfÃ¼hrbare Dateien generell verbieten**
- **Konfigurationsdateien nicht im Upload-Pfad erlauben**
- **Uploads niemals mit AusfÃ¼hrungsrechten speichern**