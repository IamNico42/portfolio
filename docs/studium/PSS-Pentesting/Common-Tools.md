---
created:
  - "{{date: DD-MM-YYYY}} {{time}}"
aliases:
  - "Course Code:"
  - PSS-Portswigger-Academy
tags:
  - Course/
---
## Pentesting Checklist



## Kali-Tools

### **Exiftool**

Ein extrem mächtiges Tool, um **Metadaten in Dateien zu lesen und zu manipulieren** (EXIF, IPTC, XMP usw.).  
Es wird im Pentesting häufig genutzt für:

- **Manipulation von Dateiinhalten**, um z. B. File-Type-Checks zu umgehen
- **Hinzu­fügen eigener Metadaten**, die Payloads enthalten können
- **Erstellen von Polyglot-Dateien** (z. B. JPEG + PHP kombiniert)
- **Anpassen der „Magic Bytes“** oder von Bildkommentaren
    

**Wichtig:**  
Exiftool verändert _normalerweise nur Metadaten_, aber manche Anwendungen prüfen nur diese Metadaten, wodurch man Filter umgehen kann.

#### Beispiel: PHP-Payload in EXIF-Kommentar schreiben

```
exiftool -Comment="<?php echo file_get_contents('/home/carlos/secret'); ?>" image.png -o image.php
```

Das Ergebnis ist eine Datei, die:
- technisch ein **PNG** bleibt
- aber **PHP-Code im Kommentar** trägt
- und mit der Endung `.php` abgespeichert wird
    

In schwachen Upload-Filtern kann das dazu führen, dass:
- das Bild **als gültiges PNG erkannt wird** (Magic Bytes stimmen)
- der Server die Datei **trotzdem als PHP interpretiert**

→ Klassischer **Content-Type / Magic Bytes Bypass**.

### **NXC - NetExec**

Ein modernes Active-Directory- und Netzwerk-Automationstool (Nachfolger von CrackMapExec).  
NXC automatisiert **Authentication, Enumeration, Lateral Movement & Exploits** über mehrere Protokolle wie **SMB, LDAP, WINRM, MSSQL, SSH** usw.

Du definierst eine **Ziel-IP / ein ganzes Netzwerk** + **Benutzerdaten**, und NXC prüft automatisch Zugriff, sammelt Infos und führt Module aus.
`nxc <protocol> <target/s> -u <user> -p <pass> [Options]`

#### Idee
- **Schnelles Testing** von AD-Rechnern auf Login
- **Automatische Enumeration** von Usern, Gruppen, OUs
- **Passwort-Validierung**
- **Shares & SMB-Daten ziehen**
- **Kerberoasting / AS-REP roasting**
- **Remote Command Execution (WINRM/SMB/SSH)*
- Alles im Stil von CME, aber schneller, stabiler, moderner
    
#### Typische Protokolle
- **LDAP** – Domain-Info, User/Groups ziehen  
- **SMB** – Shares, Lateral Movement, File-Access  
- **WINRM** – Remote Command Execution  
- **MSSQL** – SQL-Login und Enumeration  
- **SSH** – Unix Enumeration  
- **Kerberos** – Auth-Testing & Roast Attacks


### **FFUF**
Ist ein extrem schnelles Fuzzer-Tool mit dem man Verzeichnisse, Dateien, Parameter, Hosts, Subdomains und Header usw. bruteforcen kann. (dirbuster + wfuzz + gobuster in einem)

Du definierst **eine URL** und **eine Wordlist**, und ffuf ersetzt das Wort **FUZZ** durch jedes Wort aus der Wordlist.

```c
ffuf -u <URL mit FUZZ> -w <Wordlist> [Optionen]
```

#### Directory Fuzzing

```c
ffuf -u https://example.com/FUZZ -w /usr/share/wordlists/dirb/common.txt
```
#### Parameter Fuzzing
```c
ffuf -u https://example.com/login?user=admin&pass=FUZZ -w passlist.txt
```
#### Subdomain Fuzzing
```c
ffuf -u https://FUZZ.example.com -w subdomains.txt -H "Host: FUZZ.example.com"
```


```c
USAGE:
  ffuf -u URL -w WORDLIST [options]

BASIC:
  -u     Ziel-URL (FUZZ als Platzhalter)
  -w     Wordlist
  -X     HTTP Methode (GET/POST/PUT…)
  -d     POST-Daten
  -H     Header hinzufügen
  -o     Output Datei
  -of    Output Format (json,html,md)

MATCHING / FILTERING:
  -mc    Match status codes (z.B. 200,301)
  -fc    Filter status codes (z.B. 404)
  -ms    Match by response size
  -fs    Filter by size
  -mw    Match by word count
  -fw    Filter by word count
  -ml    Match by line count
  -fl    Filter by line count

PERFORMANCE:
  -t     Threads
  -rate  Requests per second limit
  -timeout Timeout pro Request

RECURSION:
  -recursion
  -recursion-depth <n>
```

### **Hash Identifier(Hashes identifizieren)**

### **Crunch(Wordlists erstellen)**
- Um Wordlists zu erstellen
### **Hashcat(Crack Hashes)**
- Hashes cracken

### **Nmap(Portscan)**

```c
sudo nmap -sV -p- -oA juiceshopfulltcp -v3 192.168.249.14
``` 
### **Gobuster(Endpunkte anzeigen)**

```c
gobuster dir -u http://192.168.249.14:3000/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt --exclude-length 75055 
```

- `dir` — Directory / file enumeration (klassischer Web-Fuzzing-Modus).
- `dns` — Subdomain-Bruteforce (Query gegen DNS).
- `vhost` — Virtual-host enumeration (nützlich, wenn Hostname verschiedene Sites serviert).
- `fuzz` — Ersetzt `FUZZ` in URL/Headers/Body — sehr flexibel (z. B. Pfade, Parameterwerte, API-Endpunkte).
- `gcs`, `s3`, `tftp` — Spezialisierte Bucket / TFTP Prüfungen.
- `completion` — Auto-completion script für deine Shell erzeugen.
- `help`, `version` — Self-explain.
    
- `-u` URL / Ziel (bei vielen Modi nötig)
- `-w` Wordlist (Pfad) — `-` = STDIN
- `-t` Threads (default 10) — mehr = schneller, aber lauter
- `-o` Output File
- `-q` Quiet, `-v` Verbose
- `--delay` Pause zwischen Threads (z. B. `1500ms`) — gut gegen IDS/Rate limits
- `--no-progress` / `--no-color` / `--no-error` — für saubere Logs oder Skripting
- `-p, --pattern` — bei `fuzz` Ersatzmusterdatei
### **Sslyze(TLS anzeigen lassen)**

```c
sslyze xxx-xx.xxx.net(Hostname)
```

### **SQLMAP (Tool zum Testen von gängigen SQLI)**

```c
sqlmap -u "http://hostname:port/rest/products/search?q=apple+juice"-p q --schema --level 5
```

- `--dbs` :
- `--tables` : Enumeriere durch Tabellen
- `--collumns` : Enumeriere durch Zeilen
- `-u URL` : Ziel-URL (z. B. `http://127.0.0.1:3000/rest/products/search?q=blah`)
- `-p TESTPARAMETER` : Prüfe genau diesen Parameter (z. B. `-p q`)
- `--cookie="name=value"` : Setze Cookie, falls Auth via Cookie (z. B. `token=...`)
- `--data="..."` : POST-Daten (für POST-Endpoints)
- `--proxy="http://127.0.0.1:8080"` : Nutze Burp/ZAP als Proxy (nützlich zum Mitloggen)
- `--level=N` (1–5) : mehr Tests / Payloads (höher = aggressiver)
- `--risk=N` (1–3) : riskantere payloads zulassen (höher = aggressiver)
- `--dbms=DBMS` : erzwinge Typ (z. B. `sqlite`) — Juice Shop nutzt oft SQLite.
- `--technique=BEUSTQ` : wähle Techniken (B=Boolean, E=Error, U=Union, S=Stacked, T=Time, Q=Inline-query)
- `--batch` : keine Rückfragen (für automatisierte Runs)
- `--flush-session` : Session-Cache löschen (nützlich für neue Tests)
- `--threads=N` : parallele Requests (vorsichtig einsetzen)
- `--crawl=N` : crawl die Site und finde Parameter (nützlich, aber zeitaufwändig)
    
Gefährlich / nur mit Vorsicht:
- `--os-shell`, `--os-pwn`, `--os-shell` → **NICHT** verwenden, wenn du nur API-Discovery willst. (Diese geben dir OS-Zugang — nicht nötig bei SQL-Audit und riskant.)

## Open-Source Tool


[SwissKy](https://swisskyrepo.github.io/PayloadsAllTheThings/)

Sammlung von Exploits, Payloads, Cheat Sheets.

[Cyber-Chef](https://gchq.github.io/CyberChef/)

Wofür man es nutzt:
- dekodieren/encodieren (Base64, hex, URL-encoding, Base32, etc.)
- schnelle Kryptotools (XOR, AES/RC4-Dekodierung _wenn du den Key hast_)
- Hashing, Prüfsummen, Umwandlung zwischen Formaten (binary↔text)
- Textanalyse / RegEx / Datenextraktion / CSV/JSON-Manipulation
- Forensik/CTF/Prototyping: man baut „Rezepte“ aus einzelnen Schritten (z. B. From Base64 → XOR → UTF-8 Decode).  
    Typische Szenarien: Log-Analyse, Reverse-engineering von Daten, CTF-Challenges, schnelle Debugging-Hilfen beim Protokollieren/Parsing.

[Jason Web Token](https://www.jwt.io/)

Was es ist: ein einfacher JWT-Debugger/Inspector (JSON Web Tokens).  
Wofür man es nutzt:
- Tokenstruktur ansehen (Header.Payload.Signature) - Header und Payload sofort base64url-dekodiert anzeigen
- Claims prüfen (exp, iat, sub, roles, etc.)
- Signatur überprüfen (wenn du das Geheimnis / den öffentlichen Schlüssel hast) - praktisch zum Debuggen von Auth-Implementierungen  
    Typische Szenarien: Backend-Entwicklung, Auth-Debugging, Verständnis/Inspektion von Tokens in APIs oder beim Pentesting (nur legal auf eigenen Systemen).

[Crackstation](https://www.crackstation.net/)

Was es ist: ein Online-Service, der bekannte Passwort-Hashes gegen riesige vorgefertigte Tabellen/Listen abgleicht (ähnlich Rainbow-Table Lookup).  
Wofür man es nutzt:
- verlorene/vergessene Passwörter wiederherstellen (wenn Hash in ihrer DB vorkommt
- prüfen, ob ein Passwort leicht in vorgefertigten Listen gefunden werden kann (Sicherheitscheck)  
    Einschränkungen: funktioniert gut bei kurzen, ungesalzenen Hashes (z. B. MD5, SHA1) und bei häufigen Passwörtern - nicht wirksam bei starken, langen oder gesalzenen Hashes. Für ernsthaftes Cracking (regelbasiert, GPU, gesalzene Hashes) benutzt man Tools wie hashcat oder John the Ripper (lokal, mit Zustimmung).


[SSLYZE](https://www.ssllabs.com/)

Was ist es: Ein Online Tool welches checkt ob das genutzte TLS vom Server den Sicherheitsstandards enstpricht. Das Ganze lässt sich alternativ manuell ausführen mit dem sslyze Befehl von Kali.
